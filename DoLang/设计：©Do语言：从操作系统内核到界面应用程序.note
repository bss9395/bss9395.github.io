!!! Record: 设计：©Do语言：从操作系统内核到界面应用程序.note
!!! Author: Brilliant9395
!!! Update: 2025/12/28⊥10:28:00&+08$08@China-BeiJing
!!! Keepin: brilliant9395@yeah.net
!!! Slogan: Life is tough, but dolang makes it easy!

### Do语言的设计原理

00. 多级指针类型与别名类型；
01. 引用类型与内存自动回收；
02. 高维数组类型与矩阵类型；
03. 函数多输入与多输出参数；
04. 编译期泛型模板与弱类型；
05. 多协程机制与读写锁机制；
06. 信号机制与事件驱动机制；

Do语言最初为开发ToDo操作系统而设计，但不兼容其它计算机语言以及操作系统。Do语言先于ToDo操作系统诞生，无须操作系统层面支持。

Do语言将成为历史上最强大也最简单的计算机语言，没有之一。

### Do语言的语言规范

00. Do语言的徽标是三叶虫。
01. Do语言的类体限定域中成员的定义顺序：嵌套共用体、嵌套组合体、嵌套类体、成员字段、成员属性、成员信号、构造方法、析构方法、成员方法、操作符方法。
02. Do语言的命名规则，下划线开头隐含本实例的this指针，单下划线开头表示公有的public，双下划线开头表示保护的protected，三下划线开头表示私有的private，四下划线开头表示局部的local。
03. Do语言的源代码文件夹以及源代码文件命名匹配({a:z}{0:9a:z}[0:](_{a:z}{0:9a:z}[0:])[0:])，源代码文件的末项后缀为#do。
04. Do语言的导入路径规则，物理文件名之前的路径采用分隔符\，物理文件名之后的路径采用分隔符.，物理文件名省略所有后缀。
05. Do语言的源代码文件夹命名匹配({a:z}{0:9a:z}[0:](_{a:z}{0:9a:z}[0:])[0:])，源代码文件命名匹配((!!)[0:1]{a:z}{0:9a:z}[0:](_{a:z}{0:9a:z}[0:])[0:])。
06. Do语言的关键字命名匹配({a:z}{0:9a:z}[3])，例外是int16、uin16、num16，其中数字表示字节长度。
07. Do语言的特性命名匹配(@{a:z}[1:])的动词。
08. Do语言的类体命名匹配(({A:Z}{0:9a:z}[0:])[1:])。
09. Do语言的泛型模板的形参为任意类型时命名匹配(({A:Z}{0:9a:z}[0:])[1:]_)，形参为字面量时命名匹配({a:z}{0:9a:z}[0:](_{a:z}{0:9a:z}[0:])[0:]_)。
10. Do语言的成员信号命名匹配(_[1:3]{A:Z}{0:9a:z}[0:](_{A:Z}{0:9a:z}[0:])[0:])。
11. Do语言的成员字段命名匹配(_{a:z}{0:9a:z}[0:](_{a:z}{0:9a:z}[0:])[0:])。
12. Do语言的成员属性命名匹配(_[1:3]{a:z}{0:9a:z}[0:](_{a:z}{0:9a:z}[0:])[0:])。
13. Do语言的局部变量命名匹配({a:z}{0:9a:z}[0:](_{a:z}{0:9a:z}[0:])[0:])。
14. Do语言的成员方法命名匹配(_[1:3]{A:Z}{0:9a:z}[0:](_{A:Z}{0:9a:z}[0:])[0:])。
15. Do语言的局部方法命名匹配(_[4]{A:Z}{0:9a:z}[0:](_{A:Z}{0:9a:z}[0:])[0:])。
16. Do语言的代码风格采用缩进4个空格，不采用缩进Tab字符，操作符方法的oper关键字与其符号之间添加1个空格。
17. Do语言的语句块的起始语句末尾不添加界定符，语句块中每条语句以分号;结尾，语句块与语句块之间可选择性地添加空行。
18. Do语言的变量在定义时必须初始化。
19. Do语言的内存分布采用顺位位节序，以及方法参数采用从左往右的入栈顺序。
20. Do语言的协程的英文单词是cotask，而不是coroutine，也不是routine。
21. Do语言的类体命名为名词时成员字段使用定点型，类体命名为形容词时成员字段使用浮点型

### Do语言的关键字与特性与操作符

Do语言的关键字是必要的，但特性不是必要的。

| 类别       | 关键字共64个                  | 关联类共8个 | C/C++语言以及Qt框架                                          | 其它语言                                                     |
| :--------- | :---------------------------- | :---------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 地址型     | iptr                          |             | nullptr_t、uintptr_t、intptr_t、ssize_t、size_t              |                                                              |
| 地址值     | null                          |             | nullptr、NULL                                                | None                                                         |
| 布尔型     | bool                          |             | bool                                                         | boolean                                                      |
| 布尔值     | posi、nega                    |             | true、false                                                  | True、False                                                  |
| 位域型     | bite                          |             |                                                              |                                                              |
| 字节型     | byte                          | Byte        | char、string、QByteArray                                     | byte、byte[]、ByteBuffer                                     |
| 字符型     | char                          | Char        | wchar_t、wstring、QString                                    | char、char[]、String、CharBuffer、StringBuilder、StringBuffer、str |
| 无符号整型 | uin4、uin8、uin16             |             | unsigned int、unsigned long、unsigned long long              |                                                              |
| 有符号整型 | int1、int2、int4、int8、int16 |             | char、short、int、long、long long                            |                                                              |
| 定长浮点型 | num4、num8、num16             |             | float、double、long double                                   |                                                              |
| 定长复数型 | com4、com8、com16             |             | complex                                                      | complex                                                      |
| 共用体     | sole                          |             | union                                                        |                                                              |
| 组合体     | pack                          |             | struct                                                       |                                                              |
| 类体       | type                          |             | struct、class                                                | class                                                        |
| 成员属性   | prop+para                     |             | property                                                     | setter()                                                     |
| 强类型     | auto                          |             | auto                                                         |                                                              |
| 弱类型     | flex                          |             |                                                              | var、let                                                     |
| 访问枚举   | enum                          | Enum        | enum                                                         | enum                                                         |
| 全量编译   | bind                          |             |                                                              |                                                              |
| 足量编译   | load                          |             | QLibrary::load()、QLibrary::unload()                         |                                                              |
| 类型别名   | take                          |             | #include、using、typedef、decltype                           | package、import                                              |
| 编译期信息 | comp                          |             | `__FILE__`、`__LINE__`、`__FUNCTION__`、 `__DATE__`、`__TIME__`、`__TIMESTAMP__` |                                                              |
| 运行期信息 | dyna                          | Dyna        | typeid、type_info                                            | .class、getClass()、Class.forName()                          |
| 入口方法   | main+hold                     | Main        | main                                                         | main                                                         |
| 生命方法   | ctor+hold                     |             |                                                              |                                                              |
| 成员方法   | func+hold                     |             |                                                              | def、function                                                |
| 操作符方法 | oper+hold                     |             | operator                                                     |                                                              |
| 方法返回   | exit                          |             | return                                                       | return                                                       |
| 条件语句   | test+else                     |             | if+else if+else、switch                                      | if+elif+else、switch                                         |
| 循环语句   | `loop+keep|quit+else`         |             | `for|while+continue|break`、 `do+continue|break+while`       | `for|while+continue|break+else`                              |
| 异常语句   | deem+cast+what+last           |             | try+throw+catch                                              | try+throw+catch+finally、try+raise+except+else+finally、with |
| 创建进程   | fork+free                     |             | fork、free、delete                                           |                                                              |
| 创建实例   | make+free                     |             | malloc、calloc、new、free、delete                            | new                                                          |
| 本进程指针 | self                          | Self        | QCoreApplication::applicationPid()                           |                                                              |
| 协程机制   | asyn+task                     | Asyn、Task  | asyn+await、this_thread::get_id()、QThread::currentThread()  | asyn+await、Thread. currentThread()                          |
| 本实例指针 | this                          |             | this                                                         | this、self                                                   |
| 信号机制   | post+emit+pick+undo           |             | signals+emit+connect+disconnect                              | getter()                                                     |
| 事件机制   | vine                          |             | parent                                                       |                                                              |
| 读写锁机制 | lock+sync                     |             | QReadWriteLock                                               | synchronized、ReentrantReadWriteLock                         |

Do语言的特性是编译期静态存储的，不支持运行期动态修改，也不支持运行期动态查询。

Do语言的特性仅对当前语句块起修饰作用。

| 特性（共8个）                         | 修饰                                               | 功能作用     | 其它语言                    |
| ------------------------------------- | -------------------------------------------------- | ------------ | --------------------------- |
| @deprecate: Version_11_0_0            | 类体、变量、方法                                   | 标记过时弃用 | [[deprecated]]、@Deprecated |
| @flag: testing ∧ (manual ∨ automated) | 类体、变量、方法、语句                             | 编译期宏条件 | #define+#if+#else+#end      |
| @suppress: Alert_unused_variable      | 类体、变量、方法、语句                             | 抑制编译警告 | (void)、#pragma warning     |
| @abstract                             | 类体、成员方法、操作符方法                         | 声明抽象定义 | abstract                    |
| @initiate                             | 成员信号、成员属性、成员字段、成员方法、操作符方法 | 声明首次定义 | virtual                     |
| @override                             | 成员信号、成员属性、成员字段、成员方法、操作符方法 | 声明再次定义 | override、@Override         |
| @throw: Exception0, Exception1        | 成员信号、成员属性、成员方法、局部方法、操作符方法 | 表明潜在异常 | noexcept、throws            |
| @apply: Unit.ctor, Unit.oper          | 类体、成员方法、局部方法、操作符方法               | 应用成员功能 | friend、using namespace     |

Do语言的操作符是预定义的，其解析方式与优先级是固定的，不支持自定义操作符。

| 类别 | 解析方式 | 语法示例                           | 操作符           | 可否重载         | 功能作用       |
| ---- | -------- | ---------------------------------- | ---------------- | ---------------- | -------------- |
| 单项 | 循环     | #b1010，b#0101                     | #                | 否               | 数字符         |
| 单项 | 循环     | 1_2345_6789.0123_4567              | _                | 否               | 连字符         |
| 单项 | 循环     | 1_2345_6789.0123_4567              | .                | 否               | 小数点         |
| 单项 | 循环     | -0.1234##-5678                     | ##               | 否               | 科学记数       |
| 单项 | 循环     | char#5                             | #                | 否               | 串长度         |
| 单项 | 循环     | 'I don't know.'，"I don't know."   | ''，""           | 否               | 字符串         |
| 单项 | 循环     | !'I don't know.'，!"I don't know." | !''，!""         | 否               | 字符数组       |
| 单项 | 循环     | #{1, 2, 3}，!{1, 2, 3}             | #{}，!{}         | 否               | 初始化数组     |
| 单项 | 循环     | a + (b - c)                        | ()               | 否               | 优先运算       |
| 单项 | 循环     | [0, 1, 2, 3]                       | []               | 否               | 一维数组       |
| 单项 | 循环     | 〈0, 1, 2, 3〉                     | 〈〉             | 否               | 一维数组       |
|      |          |                                    |                  |                  |                |
| 取址 | 递归     | auto pointer ⊏ $variable           | $                | 否               | 取指针         |
| 取址 | 递归     | auto alias ⊏ &variable             | &                | 否               | 取别名         |
| 取址 | 递归     | auto reference ⊏ &&pointer         | &&               | 否               | 取引用         |
| 取址 | 递归     | $Type0._memb                       | $                | 否               | 基层指针转换   |
|      |          |                                    |                  |                  |                |
| 调用 | 循环     | take \folder\file.Type = Alias     | \                | 否               | 实文件路径     |
| 调用 | 循环     | take \folder\file.Type = Alias     | .                | 否               | 虚文件路径     |
| 调用 | 循环     | `object\_Funtion〈parameter〉`     | \                | 否               | 体访问         |
| 调用 | 循环     | pointer.                           | .                | 可               | 解地址         |
| 调用 | 循环     | pointer._Function〈parameter〉     | .                | 可               | 实访问         |
| 调用 | 循环     | pointer:_Function〈parameter〉     | :                | 可               | 虚访问         |
| 调用 | 循环     | auto vector ⊏ Vector{}             | {}               | 可               | 类初始化       |
| 调用 | 循环     | _Function〈parameter〉             | 〈〉             | 可               | 方法调用       |
| 调用 | 循环     | array[demention0, demention1]      | []               | 可               | 数组下标       |
| 调用 | 循环     | ∀x::setX{_Pred〈x〉};              | ∀                | 否               | 全称量词       |
| 调用 | 循环     | ∃x::setX{_Pred〈x〉};              | ∃                | 否               | 存在量词       |
| 调用 | 循环     | Ⅎx::setX{_Pred〈x〉};              | Ⅎ                | 否               | 特称量词       |
|      |          |                                    |                  |                  |                |
| 后缀 | 循环     | M′                                 | ′                | 可               | 逆矩阵         |
|      |          |                                    |                  |                  |                |
| 乘方 | 递归     | -a ·· b ·· c                       | ··               | 可               | 幂法           |
| 乘方 | 递归     | -_F⌃2〈x〉                         | ⌃                | 可               | 指数           |
|      |          |                                    |                  |                  |                |
| 前缀 | 递归     | °-361.0123                         | °                | 否               | 角度           |
| 前缀 | 递归     | °-361.0123                         | °，圆圈带横      | 否               | 弧度           |
| 前缀 | 递归     | ⌟M                                 | ⌟                | 可               | 转置矩阵       |
| 前缀 | 递归     | ┕c                                 | ┕                | 可               | 共轭复数       |
| 前缀 | 递归     | !a                                 | !                | 可               | 表示实例       |
| 前缀 | 递归     | ∽a                                 | ∽，下上下        | 可               | 按位非         |
| 前缀 | 递归     | ¬a                                 | ¬                | 可               | 逻辑非         |
| 前缀 | 递归     | -a                                 | -                | 可，单目         | 负号           |
| 前缀 | 递归     | +a                                 | +                | 可，单目         | 正号           |
| 前缀 | 递归     | ++iterator;                        | ++               | 可               | 前自增         |
| 前缀 | 递归     | --iterator;                        | --               | 可               | 前自减         |
| 前缀 | 递归     | (int8)1234.5678                    | ()               | 否               | 类型转换       |
|      |          |                                    |                  |                  |                |
| 乘除 | 循环     | a · b                              | ·                | 可               | 乘法           |
| 乘除 | 循环     | a / b                              | /                | 可               | 浮点除法       |
| 乘除 | 循环     | a // b                             | //               | 可               | 截断除法       |
| 乘除 | 循环     | a % b                              | %，左右为实心点  | 可               | 浮点模法       |
| 乘除 | 循环     | a %% b                             | %%，左右为实心点 | 可               | 截断模法       |
| 乘除 | 循环     | 1.0::wrule^1                       | ::               | 可，三目         | 单位转换       |
|      |          |                                    |                  |                  |                |
| 加减 | 循环     | a + b - c                          | +                | 可，双目         | 加法           |
| 加减 | 循环     | a + b - c                          | -                | 可，双目         | 减法           |
|      |          |                                    |                  |                  |                |
| 移位 | 循环     | integer << i                       | <<               | 可               | 向左移位       |
| 移位 | 循环     | integer >> i                       | >>               | 可               | 向右移位       |
| 移位 | 循环     | stream <<< value                   | <<<              | 可               | 正序列化       |
| 移位 | 循环     | stream >>> value                   | >>>              | 可               | 反序列化       |
|      |          |                                    |                  |                  |                |
| 按位 | 循环     | a ∧∧ b                             | ∧∧               | 可               | 按位与         |
| 按位 | 循环     | a ∨∨ b                             | ∨∨               | 可               | 按位或         |
| 按位 | 循环     | a ⊔⊔ b                             | ⊔⊔               | 可               | 按位异         |
|      |          |                                    |                  |                  |                |
| 比较 | 循环     | a < b                              | <                | 可               | 小于           |
| 比较 | 循环     | a <= b                             | <=               | 可               | 小于等于       |
| 比较 | 循环     | a > b                              | >                | 可               | 大于           |
| 比较 | 循环     | a >= b                             | >=               | 可               | 大于等于       |
| 比较 | 循环     | a <=> b                            | <=>              | 可               | 三路比较       |
| 比较 | 循环     | a = b                              | =                | 可               | 等于           |
| 比较 | 循环     | a == b                             | ==               | 可               | 恒等于         |
| 比较 | 循环     | a ¬= b                             | ¬=               | 否               | 非等于         |
| 比较 | 循环     | a ¬== b                            | ¬==              | 否               | 非恒等于       |
|      |          |                                    |                  |                  |                |
| 逻辑 | 循环     | a ∧ b                              | ∧                | 可               | 逻辑与，全路与 |
| 逻辑 | 循环     | a ∨ b                              | ∨                | 可               | 逻辑或，全路或 |
| 逻辑 | 循环     | a ⊔ b                              | ⊔                | 可               | 逻辑异，全路异 |
| 逻辑 | 循环     | `a ? b ?? c`                       | `?`              | 否，双目以及三目 | 条件与，短路与 |
| 逻辑 | 循环     | `a | b || c`                       | `|`              | 否，双目以及三目 | 条件或，短路或 |
|      |          |                                    |                  |                  |                |
| 推导 | 循环     | a → b                              | →                | 可               | 逻辑蕴含       |
| 推导 | 循环     | a ↔ b                              | ↔                | 可               | 逻辑等价       |
|      |          |                                    |                  |                  |                |
| 复合 | 递归     | a +⊏ b                             | +⊏               | 否               | 加法赋值       |
| 复合 | 递归     | a -⊏ b                             | -⊏               | 否               | 减法赋值       |
| 复合 | 递归     | integer >>⊏ i                      | >>⊏              | 否               | 右移赋值       |
| 复合 | 递归     | integer <<⊏ i                      | <<⊏              | 否               | 左移赋值       |
| 复合 | 递归     | a ∧∧⊏ b                            | ∧∧⊏              | 否               | 按位与赋值     |
| 复合 | 递归     | a ∨∨⊏ b                            | ∨∨⊏              | 否               | 按位或赋值     |
| 复合 | 递归     | a ⊔⊔⊏ b                            | ⊔⊔⊏              | 否               | 按位异赋值     |
|      |          |                                    |                  |                  |                |
| 赋值 | 递归     | type Derived: Base                 | :                | 否               | 类型继承       |
| 赋值 | 递归     | take type00_type11: type00_type10  | :                | 否               | 类型转换       |
| 赋值 | 递归     | func _Function〈parameter: int8〉  | :                | 否               | 参量写         |
| 赋值 | 递归     | func _Function〈parameter:> int8〉 | :>               | 否               | 参量读         |
| 赋值 | 递归     | auto writable ⊏ variable           | ⊏                | 否               | 赋值写         |
| 赋值 | 递归     | auto readable ⊏> variable          | ⊏>               | 否               | 赋值读         |
|      |          |                                    |                  |                  |                |
| 分隔 | 循环     | auto width, factor ⊏ _Function〈〉 | ,                | 否               | 逗号           |
| 分隔 | 循环     | auto assign ⊏ variable;            | ;                | 否               | 分号           |
|      |          |                                    |                  |                  |                |
| 辅助 | 循环     | @initiate                          | @                | 否               | 特性           |
| 辅助 | 循环     | !! comments                        | !!               | 否               | 单行文本注释   |
| 辅助 | 循环     | !!! author: brilliant9395          | !!!              | 否               | 多行文档注释   |

### Do语言的注释与日志

相关关键词：单行文本注释、多行文档注释、文本朴素式、图形图像式、日志、日志等级

Do语言只支持单行文本注释与多行文档注释，Do语言的注释仅对当前语句块起修饰作用。
单行文本注释从注释符号!! 加空格忽略缩进起始到换行符结束，注释内容按UCS字符集文本朴素式处理。
多行文档注释从注释符号!!!加空格以及缩进起始到换行符结束，注释内容由以冒号:分隔的键值对组成，键按UCS字符集文本朴素式处理，值按UCS字符集图形图像式处理。多行文档注释可以表示嵌套层次结构。

!!! Do语言的多行文档注释的示例
!!! Author: brilliant9395
!!! Update: 2026/01/03⊥16:25:00&+08$08@China-BeiJing
type Main
    !!! Action: 程序入口方法
    !!! Params:
    !!!     help: bool; 是否打印帮助
    !!! Return:
    !!!     code: int8; 方法返回码
    !!!         +0: 方法正常结束
    !!!         -1: 方法异常结束
    main Main{help: bool} ⊏> code: int8
        exit +0;  !! Do语言的单行文本注释的示例

!! Do语言的日志等级的示例
type Logger
    type Enum
        take uin4 = Level;
        prop _noone ⊏> Level{b#10 >> 0};
        prop _fatal ⊏> Level{b#10 >> 1};
        prop _error ⊏> Level{b#10 >> 2};
        prop _alert ⊏> Level{b#10 >> 3};
        prop _debug ⊏> Level{b#10 >> 4};
        prop _trace ⊏> Level{b#10 >> 5};
        prop _whole ⊏> Level{_fatal ∨∨ _error ∨∨ _alert ∨∨ _debug ∨∨ _trace};

type Main
    main Main{}
        Logger._level ⊏ Logger.Enum._debug;
        Logger._Fatal〈!'fatal error'〉;
        Logger._Error〈!'critical error'〉;
        Logger._Alert〈!'alerting'〉;
        Logger._Debug〈!'debugging'〉;
        Logger._Trace〈!'tracing'〉;

### Do语言的内存序与字符编码

相关关键词：运行栈、分配堆、银行位节序、数字位节序、网络位节序、顺位位节序、UCS1、UCS2

Do语言的可存储内存只有两种：运行栈与分配堆。Do语言的内存是连续排列的，通常也不需要考虑变量对齐内存边界，例外是位域变量需要考虑对齐内存边界。

Do语言的内存序称为顺位位节序，Do语言内存序只支持顺位位节序。值得注意的是，Do语言的运行栈内存是从低地址向高地址生长的，然而C/C++语言的运行栈内存是从高地址向低地址生长的。

目前人类语言的书写顺序有四种：银行位节序、数字位节序（也即小端位节序）、网络位节序（也即大端位节序）、顺位位节序。

考虑使用一维字节数组存储语句"Number 2 is Positive."，其中字母在内存中表示为字节型二进制8位，数字在内存中表示为有符号整型二进制16位。内存最高位为符号位，符号位为0表示负数，符号位为1表示正数。

银行位节序，银行位节序就是人类文字的顺序。
内存低地址                                          内存高地址
[0]           [7]      [8]
|N|u|m|b|e|r| |10000000|00000010| |i|s| |P|o|s|i|t|i|v|e|.|
银行位节序按十六进制打印输出为"Number 8002 is Positive."。

数字位节序，数字位节序就是数字表示的顺序，也即小端位节序。
内存高地址                                          内存低地址
                                 [8]      [7]           [0]
|.|e|v|i|t|i|s|o|P| |s|i| |10000000|00000010| |r|e|b|m|u|N|
数字位节序按十六进制打印输出为"Number 8002 is Positive."。

网络位节序，网络位节序与小端位节序正好是位序相同节序相反，也即大端位节序。网络位节序是一种不恰当的位节序，其根源于小端位节序。
内存高地址                                          内存低地址
                                 [8]      [7]           [0]
|.|e|v|i|t|i|s|o|P| |s|i| |00000010|10000000| |r|e|b|m|u|N|
网络位节序按十六进制打印输出为"Number 0280 is Positive."。

顺位位节序，顺位位节序就是按位排列的顺序。顺位位节序与人类文字的书写顺序保持一致。
内存低地址                                          内存高地址
|N|u|m|b|e|r| |01000000|00000001| |i|s| |P|o|s|i|t|i|v|e|.|
顺位位节序按十六进制打印输出为"Number 2008 is Positive."。


Do语言的源代码文件以及终端命令行以及内部编码都采用UCS字符集，Do语言只支持UCS字符集。Do语言的符号表采用其它编码方案，以防止符号表信息暴露。

UCS字符集包括UCS1、UCS2，英文全称Universal Character Set，中文全称万有字符集。
UCS字符集采用2字节编码方案，可按紧凑模式或者码表模式存储，紧凑模式与码表模式可无损转换。
UCS1字符占用内存1bytes，码位位宽为07bites，第8位为扩展位0，UCS1字符集的容量为2··(07) = 00128个码位。UCS1字符按码表模式存储时，第8位到第16位全为0。
UCS2字符占用内存2bytes，码位位宽为15bites，第8位为扩展位1，UCS2字符集的容量为2··(07) + 2··(15) = 32896个码位。将UCS2编码截断为07bites就是UCS1编码。

UCS字符集即是字符集族也是编码集族，UCS字符集在读写数据时无需转码操作，采用UCS字符集的文本文件与二进制文件没有任何区别。值得注意的是，Unicode字符集族只是字符集族不是编码集族，UTF8编码集只是编码集不是字符集，UTF8编码集在读写数据时需要转码操作，采用UTF8编码集的文本文件与二进制文件应当区分对待。

UCS字符集规定至少支持3种可视化形式：十六进制式（没有换行）、文本朴素式（可选换行）、图形图像式（只有换行）。UCS字符集中的空档字符显示为其UCS编码的十六进制数字，按顺位位节序从下到上从左到右排列，UCS1字符为1个英文字母宽度，UCS2字符为2个英文字母宽度。

### Do语言的原码芯片与数字信号

相关关键词：中央处理器、二态数字电路、补码芯片、原码芯片、加法器、减法器、加法运算、减法运算、同号运算、异号运算、线性同余定理、原码、反码、补码、运算模数、数字信号、正轴信号、校准信号、异轴信号

Do语言只支持64位中央处理器，不支持32位中央处理器，也不支持128位中央处理器。因为32位中央处理器寻址不足且运算低下，128位中央处理器架构复杂且功耗过载。

数字电路是二态数字电路，数字0表示低电平，数字1表示高电平。多态数字电路既不稳健，也不利于补码运算。

补码芯片的有符号整型的零有一个表示，正零与负零相同，无法与扩展的数轴（包含-∞与+∞）建立起一一对应关系。
原码芯片的有符号整型的零有两个表示，正零优先于负零，可以与扩展的数轴（包含-∞与+∞）建立起一一对应关系。
补码芯片有加法器没有减法器，四则运算分为加法运算与减法运算。
原码芯片有加法器也有减法器，四则运算转为同号运算与异号运算。
原码芯片更复合人类的四维方式。

线性同余定理：
[规约性] 有a modu M ∈ [0:M〉
[对称性] 若a modu M = b modu M，则b modu M = a modu M
[传递性] 若a modu M = b modu M，且b modu M = c modu M，则a modu M = c modu M
[模运算] 若a modu M = A modu M，则(a + k · M) modu M = A modu M
[加运算] 若a modu M = A modu M，且b modu M = B modu M，则(a + b) modu M = (A + B) modu M
[减运算] 若a modu M = A modu M，且b modu M = B modu M，则(a - b) modu M = (A - B) modu M
[乘运算] 若a modu M = A modu M，且b modu M = B modu M，则(a · b) modu M = (A · B) modu M

补码芯片定长整型加法器定理，折合为2个，其中(M - b modu M)为b的补码。
[加法运算] (a + b) modu M = (a modu M + b modu M) modu M
[减法运算] (a - b) modu M = (a modu M + (M - b modu M)) modu M

原码芯片定长整型运算器定理，折合为5个，其中(N - sc modu N)为sc的补码。
情形零，正数加正数，可能向上溢出。
情形一，负数加负数，可能向下溢出。
情形二，正数加负数，可能是正数也可能是负数。
情形三，负数加正数，可能是负数也可能是正数。
[同号加法器运算       ] (sa + sb) modu N = (sa modu N + sb modu N) modu N
[异号减法器运算，无借出] (sa - sb) modu N = (sa modu N - sb modu N) modu N
[异号减法器运算，有借出] (N + sa - sb) modu N = sc modu N，(sa - sb) modu N = -(N - sc modu N) modu N

补码芯片的有符号整型的零有一个表示，正零与负零相同。
补码芯片的四位有符号整型的运算逻辑，符号位也参与运算，运算模数是16。
补码芯片的正数与负数都存储为其补码，正数的符号位是0，负数的符号位是1。
补码芯片的正数的补码是其原码即本身，补码芯片的负数的补码是其原码按位取反后加一。

| 原码有符号 | 原码iiii，反码iiii | 补码iiii modu 16 |
| ---------- | ------------------ | ---------------- |
| +7         | 0b0111，0b0111     | 0b0111           |
| +6         | 0b0110，0b0110     | 0b0110           |
| +5         | 0b0101，0b0101     | 0b0101           |
| +4         | 0b0100，0b0100     | 0b0100           |
| +3         | 0b0011，0b0011     | 0b0011           |
| +2         | 0b0010，0b0010     | 0b0010           |
| +1         | 0b0001，0b0001     | 0b0001           |
| ±0         | 0b0000，0b0000     | 0b0000           |
| -1         | 0b1001，0b1110     | 0b1111           |
| -2         | 0b1010，0b1101     | 0b1110           |
| -3         | 0b1011，0b1100     | 0b1101           |
| -4         | 0b1100，0b1011     | 0b1100           |
| -5         | 0b1101，0b1010     | 0b1011           |
| -6         | 0b1110，0b1001     | 0b1010           |
| -7         | 0b1111，0b1000     | 0b1001           |
| -8         | 0b1000，0b0111     | 0b1000           |

// 补码芯片加法运算
正数+正数，(+2)+(+2) = (+4)
 0010
+0010
=0100

正数+负数，(+2)+(-2) = (±0)
 0010
+1110
=0000

负数+正数，(-2)+(+2) = (±0)
 1110
+0010
=0000

负数+负数，(-2)+(-2) = (-4)
 1110
+1110
=1100

// 补码芯片减法运算
正数-正数，(+2)-(+2) = (+2)+(-2) = (±0)
 0010         0010
-0010  1101  +1110
=            =0000

正数-负数，(+2)-(-2) = (+2)+(+2) = (+4)
 0010         0010
-1110  0001  +0010
=            =0100

负数-正数，(-2)-(+2) = (-2)+(-2) = (-4)
 1110         1110
-0010  1101  +1110
=            =1100

负数-负数，(-2)-(-2) = (-2)+(+2) = (±0)
 1110         1110
-1110  0001  +0010
=            =0000

// 补码芯片正数溢出
正数溢出，(+7)+(+1) = (-8)
 0111
+0001
=1000

正数溢出，(+7)+(+2) = (-7)
 0111
+0010
=1001

// 补码芯片负数溢出
负数压界，(-7)+(-1) = (-8)
 1001
+1111
=1000

负数溢出，(-8)+(-1) = (+7)
 1000
+1111
=0111


原码芯片的有符号整型的零有两个表示，正零优先于负零。
原码芯片的四位有符号整型的运算逻辑，符号位不参与运算，运算模数是8。
原码芯片的正数与负数都存储为其原码，正数的符号位是1，负数的符号位是0。

| 原码有符号 | 原码siii | 反码siii，补码siii modu 8 |
| ---------- | -------- | ------------------------- |
| +7         | #b1111   | #b1000，#b1001            |
| +6         | #b1110   | #b1001，#b1010            |
| +5         | #b1101   | #b1010，#b1011            |
| +4         | #b1100   | #b1011，#b1100            |
| +3         | #b1011   | #b1100，#b1101            |
| +2         | #b1010   | #b1101，#b1110            |
| +1         | #b1001   | #b1110，#b1111            |
| +0         | #b1000   | #b1111，#b1000            |
| -0         | #b0000   | #b0111，#b0000            |
| -1         | #b0001   | #b0110，#b0111            |
| -2         | #b0010   | #b0101，#b0110            |
| -3         | #b0011   | #b0100，#b0101            |
| -4         | #b0100   | #b0011，#b0100            |
| -5         | #b0101   | #b0010，#b0011            |
| -6         | #b0110   | #b0001，#b0010            |
| -7         | #b0111   | #b0000，#b0001            |

!! 原码芯片同号加法器运算
正数+正数，(+2)+(+2) = (+4)
 1010
+1010
=1100  无溢出

正数+正数，(+2)+(+6) = (+0)
 1010
+1110
=1000  有溢出

正数+正数，(+4)+(+6) = (+2)
 1100
+1110
=1010  有溢出

负数+负数，(-2)+(-2) = (-4)
 0010
+0010
=0100  无溢出

负数+负数，(-2)+(-6) = (-0)
 0010
+0110
=0000  有溢出

负数+负数，(-4)+(-6) = (-2)
 0100
+0110
=0010  有溢出

!! 原码芯片异号减法器运算
正数+负数，(+4)+(-1) = (+3)
   ··  无借出
 1100
+0001
=1011

正数+负数，(+4)+(-7) = (-3)
  ···  有借出
 1100
+0111
=1101  0010  0011

正数+负数，(+4)+(-4) = (+0)
       无借出
 1100
+0100
=1000

负数+正数，(-4)+(+1) = (-3)
   ··  无借出
 0100
+1001
=0011

负数+正数，(-4)+(+7) = (+3)
  ···  有借出
 0100
+1111
=0101  1010  1011

负数+正数，(-4)+(+4) = (-0)
       无借出
 0100
+1100
=0000

加法器逻辑真值表：
| 出进位carryout | 和sum | 被加数addend | 加数plusend | 入进位carryin |
| :------------: | :---: | :----------: | :---------: | :-----------: |
|       0        |   0   |      0       |      0      |       0       |
|       0        |   1   |      0       |      1      |       0       |
|       0        |   1   |      1       |      0      |       0       |
|       1        |   0   |      1       |      1      |       0       |
|       0        |   1   |      0       |      0      |       1       |
|       1        |   0   |      0       |      1      |       1       |
|       1        |   0   |      1       |      0      |       1       |
|       1        |   1   |      1       |      1      |       1       |

加法器逻辑数字电路：
[根据日常识] carryout · 2 + sum = addend + plusend + carryin;
[根据日常识] carryout ⊏ (addend ∧ plusend) ∨ (addend ∧ carryin) ∨ (plusend ∧ carryin);
[根据真值表] sum      ⊏ addend ⊔ plusend ⊔ carryin;
[根据真值表] carryout ⊏ (addend ∧ (plusend ⊔ carryin)) ∨ (plusend ∧ carryin);

减法器逻辑真值表：
| 出借位borrowout | 差difference | 被减数subtractend | 减数minusend | 入借位borrowin |
| :-------------: | :----------: | :---------------: | :----------: | :------------: |
|        0        |      0       |         0         |      0       |       0        |
|        1        |      1       |         0         |      1       |       0        |
|        0        |      1       |         1         |      0       |       0        |
|        0        |      0       |         1         |      1       |       0        |
|        1        |      1       |         0         |      0       |       1        |
|        1        |      0       |         0         |      1       |       1        |
|        0        |      0       |         1         |      0       |       1        |
|        1        |      1       |         1         |      1       |       1        |

减法器逻辑数字电路：
[根据日常识] borrowout · 2 + subtractend = difference + minusend + borrowin;
[根据日常识] borrowout  ⊏ (¬subtractend ∧ (minusend ∨ borrowin)) ∨ (subtractend ∧ minusend ∧ borrowin);
[根据真值表] difference ⊏ subtractend ⊔ minusend ⊔ borrowin;
[根据真值表] borrowout  ⊏ (¬subtractend ∧ (minusend ⊔ borrowin)) ∨ (minusend ∧ borrowin);


补码芯片只有正轴信号与校准信号：
补码芯片正轴信号转换为校准信号，最高位取反。
补码芯片校准信号转换为正轴信号，最高位取反。

原码芯片分为异轴信号与正轴信号：
原码芯片异轴信号转换为正轴信号，正值不转码，负值转补码，负零转补码溢出保留。
原码芯片正轴信号转换为异轴信号，高值不转码，低值转补码，零值转补码溢出丢弃。

| 4位异轴信号，以±0为基准 | 4位正轴信号，以8为基准 | 4位校准信号 |
| ----------------------- | ---------------------- | ----------- |
| #b1111，+7              | #b1111，15             | 0b0111，+7  |
| #b1110，+6              | #b1110，14             | 0b0110，+6  |
| #b1101，+5              | #b1101，13             | 0b0101，+5  |
| #b1100，+4              | #b1100，12             | 0b0100，+4  |
| #b1011，+3              | #b1011，11             | 0b0011，+3  |
| #b1010，+2              | #b1010，10             | 0b0010，+2  |
| #b1001，+1              | #b1001，9              | 0b0001，+1  |
| #b1000，+0              | #b1000，8              | 0b0000，+0  |
| #b0000，-0              |                        |             |
| #b0001，-1              | #b0111，7              | 0b1111，-1  |
| #b0010，-2              | #b0110，6              | 0b1110，-2  |
| #b0011，-3              | #b0101，5              | 0b1101，-3  |
| #b0100，-4              | #b0100，4              | 0b1100，-4  |
| #b0101，-5              | #b0011，3              | 0b1011，-5  |
| #b0110，-6              | #b0010，2              | 0b1010，-6  |
| #b0111，-7              | #b0001，1              | 0b1001，-7  |
|                         | #b0000，0              | 0b1000，-8  |

### Do语言的定长浮点型

相关关键词：IEEE浮点数格式、Do语言浮点数格式

IEEE定长32位浮点数格式，偏码取127则值域基本对称。
                    0x9876543210
±ssssssssfffffffffffffffffffffff
1       8                     23
bias                 = 2··(8-1)-1             = 127
shift-bias           = [1:254]-127            = [-126:+127]
number               = (-1)··sign · 2··(shift-bias) · 1.fraction
precision            = loga10〈2··23〉         ≈ 6.92
effective            = loga10〈2··(23+1)〉     ≈ 7.22
minimum_unnormalized = 2··(-127)·2··(-23)     ≈ 7.00·10··(-46)
maximum_unnormalized = 2··(-127)·(1-2··(-23)) ≈ 5.88·10··(-39)
minimum_normalized   = 2··(-126)              ≈ 1.18·10··(-38)
maximum_normalized   = 2··(+127)·(2-2··(-23)) ≈ 3.40·10··(+38)

| 数值           | 真值                                | 数符1位 | 移码8位    | 尾码23位                    |
| -------------- | ----------------------------------- | ------- | ---------- | --------------------------- |
| 零             | ±0.0                                | ±       | 0b00000000 | 0b0.00000000000000000000000 |
| 最小非规格化数 | ±2··(-127)·2··(-23)                 | ±       | 0b00000000 | 0b0.00000000000000000000001 |
| 非规格化数     | ±2··(-127)·[2··(-23):1-2··(-23)]    | ±       | 0b00000000 | 0b0.fffffffffffffffffffffff |
| 最大非规格化数 | ±2··(-127)·(1-2··(-23))             | ±       | 0b00000000 | 0b0.11111111111111111111111 |
|                | 间隔跳跃                            |         | 硬件中断   | 间隔跳跃                    |
| 最小规格化数   | ±2··(-126)                          | ±       | 0b00000001 | 0b1.00000000000000000000000 |
| 规格化数       | ±[2··(-126):2··(+127)·(2-2··(-23))] | ±       | 0bssssssss | 0b1.fffffffffffffffffffffff |
| 最大规格化数   | ±2··(+127)·(2-2··(-23))             | ±       | 0b11111110 | 0b1.11111111111111111111111 |
|                |                                     |         | 硬件中断   |                             |
| 无穷大         | ±∞                                  | ±       | 0b11111111 | 0b0.00000000000000000000000 |
| 非数           | ±ϰ                                  | ±       | 0b11111111 | 0b0.fffffffffffffffffffffff |

IEEE定长64位浮点数格式，偏码取1023则值域基本对称。
                                                    0x9876543210
±sssssssssssffffffffffffffffffffffffffffffffffffffffffffffffffff
1         11                                                  52
bias                 = 2··(11-1)-1             = 1023
shift-bias           = [1:2046]-1023           = [-1022:+1023]
number               = (-1)··sign · 2··(shift-bias) · 1.fraction
precission           = loga10〈2··52〉          ≈ 15.65
effective            = loga10〈2··(52+1)〉      ≈ 15.95
minimum_unnormalized = 2··(-1023)·2··(-52)     ≈ 2.47·10··(-324)
maximum_unnormalized = 2··(-1023)·(1-2··(-52)) ≈ 1.11·10··(-308)
minimum_normalized   = 2··(-1022)              ≈ 2.23·10··(-308)
maximum_normalized   = 2··(+1023)·(2-2··(-52)) ≈ 1.80·10··(+308)

| 数值           | 真值                                  | 数符1位 | 移码11位      | 尾码52位                                                 |
| -------------- | ------------------------------------- | ------- | ------------- | -------------------------------------------------------- |
| 零             | ±0.0                                  | ±       | 0b00000000000 | 0b0.0000000000000000000000000000000000000000000000000000 |
| 最小非规格化数 | ±2··(-1023)·2··(-52)                  | ±       | 0b00000000000 | 0b0.0000000000000000000000000000000000000000000000000001 |
| 非规格化数     | ±2··(-1023)·[2··(-52):1-2··(-52)]     | ±       | 0b00000000000 | 0b0.ffffffffffffffffffffffffffffffffffffffffffffffffffff |
| 最大非规格化数 | ±2··(-1023)·(1-2··(-52))              | ±       | 0b00000000000 | 0b0.1111111111111111111111111111111111111111111111111111 |
|                | 间隔跳跃                              |         | 硬件中断      | 间隔跳跃                                                 |
| 最小规格化数   | ±2··(-1022)                           | ±       | 0b00000000001 | 0b1.0000000000000000000000000000000000000000000000000000 |
| 规格化数       | ±[2··(-1022):2··(+1023)·(2-2··(-52))] | ±       | 0bsssssssssss | 0b1.ffffffffffffffffffffffffffffffffffffffffffffffffffff |
| 最大规格化数   | ±2··(+1023)·(2-2··(-52))              | ±       | 0b11111111110 | 0b1.1111111111111111111111111111111111111111111111111111 |
|                |                                       |         | 硬件中断      |                                                          |
| 无穷大         | ±∞                                    | ±       | 0b11111111111 | 0b0.0000000000000000000000000000000000000000000000000000 |
| 非数           | ±ϰ                                    | ±       | 0b11111111111 | 0b0.ffffffffffffffffffffffffffffffffffffffffffffffffffff |


Do语言定长32位浮点数格式，偏码取62则值域基本对称。
h#0123456789
ffffffffffffffffffffffffsssssss±
24                      7      1
bias       = 2··(7-1)-2            = 62
shift-bias = [1:126]-62            = [-61:+64]
number     = (-1)··sign · 2··(shift-bias) · 0.fraction
precision  = loga10〈2··(24-1)〉    ≈ 6.92
effective  = loga10〈2··24〉        ≈ 7.22
infimum    = 2··(-62)·2··(-24)     ≈ 1.29·10··(-26)
minimum    = 2··(-61)·2··(-1)      ≈ 2.17·10··(-19)
maximum    = 2··(+64)·(1-2··(-24)) ≈ 1.84·10··(+19)

| 数值   | 真值                                      | 尾码24位                      | 移码7位   | 数符1位 |
| ------ | ----------------------------------------- | ----------------------------- | --------- | ------- |
| 零     | ±0.0                                      | b#000000000000000000000000.0  | b#0000000 | ±       |
| 渐进小 | ±2··(-62)·[2··(-24):1-2··(-24)]           | b#ffffffffffffffffffffffff.0  | b#0000000 | ±       |
| 最小数 | ±2··(-61)·2··(-1)                         | b#0000000000000000000000001.0 | b#1000000 | ±       |
| 规范数 | ±[2··(-61)·2··(-1):2··(+64)·(1-2··(-24))] | b#fffffffffffffffffffffff1.0  | b#sssssss | ±       |
| 最大数 | ±2··(+64)·(1-2··(-24))                    | b#111111111111111111111111.0  | b#0111111 | ±       |
|        |                                           | 硬件中断                      |           |         |
| 无穷大 | ±∞                                        | b#ffffffffffffffffffffffff.0  | b#1111111 | ±       |
| 非数   | ±ϰ                                        | b#111111111111111111111111.0  | b#1111111 | ±       |

Do语言定长64位浮点数格式，偏码取254则值域基本对称。
h#0123456789
ffffffffffffffffffffffffffffffffffffffffffffffffffffffsssssssss±
54                                                    9        1
bias       = 2··(9-1)-2             = 254
shift-bias = [1:510]-254            = [-253:+256]
number     = (-1)··sign · 2··(shift-bias) · 0.fraction
precision  = loga10〈2··(54-1)〉     ≈ 15.95
effective  = loga10〈2··54〉         ≈ 16.26
infimum    = 2··(-254)·2··(-54)     ≈ 1.92·10··(-93)
minimum    = 2··(-253)·2··(-1)      ≈ 3.45·10··(-77)
maximum    = 2··(+256)·(1-2··(-54)) ≈ 1.16·10··(+77)

| 数值   | 真值                                        | 尾码54位                                                   | 移码9位     | 数符1位 |
| ------ | ------------------------------------------- | ---------------------------------------------------------- | ----------- | ------- |
| 零     | ±0.0                                        | b#000000000000000000000000000000000000000000000000000000.0 | b#000000000 | ±       |
| 渐进小 | ±2··(-254)·[2··(-54):1-2··(-54)]            | b#ffffffffffffffffffffffffffffffffffffffffffffffffffffff.0 | b#000000000 | ±       |
| 最小数 | ±2··(-253)·2··(-1)                          | b#000000000000000000000000000000000000000000000000000001.0 | b#100000000 | ±       |
| 规范数 | ±[2··(-253)·2··(-1):2··(+256)·(1-2··(-54))] | b#fffffffffffffffffffffffffffffffffffffffffffffffffffff1.0 | b#sssssssss | ±       |
| 最大数 | ±2··(+256)·(1-2··(-54))                     | b#111111111111111111111111111111111111111111111111111111.0 | b#011111111 | ±       |
|        |                                             | 硬件中断                                                   |             |         |
| 无穷大 | ±∞                                          | b#ffffffffffffffffffffffffffffffffffffffffffffffffffffff.0 | b#111111111 | ±       |
| 非数   | ±ϰ                                          | b#111111111111111111111111111111111111111111111111111111.0 | b#111111111 | ±       |

Do语言定长128位浮点数格式，偏码取1022则值域基本对称。
h#0123456789
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffsssssssssss±
116                                                                                                                 11         1
bias       = 2··(11-1)-2              = 1022
shift-bias = [1:2046]-1022            = [-1021:+1024]
number     = (-1)··sign · 2··(shift-bias) · 0.fraction
precision  = loga10〈2··(116-1)〉      ≈ 34.62
effective  = loga10〈2··116〉          ≈ 34.92
infimum    = 2··(-1022)·2··(-116)     ≈ 2.68·10··(-343)
minimum    = 2··(-1021)·2··(-1)       ≈ 2.23·10··(-308)
maximum    = 2··(+1024)·(1-2··(-116)) ≈ 1.80·10··(+308)

| 数值     | 真值                                           | 尾码116位                                                    | 移码11位      | 数符1位 |
| -------- | ---------------------------------------------- | ------------------------------------------------------------ | ------------- | ------- |
| 零       | ±0.0                                           | b#00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0 | b#00000000000 | ±       |
| 渐进小   | ±2··(-1022)·[2··(-116):1-2··(-116)]            | b#ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff.0 | b#00000000000 | ±       |
| 最小数   | ±2··(-1021)·2··(-1)                            | b#00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001.0 | b#10000000000 | ±       |
| 规格化数 | ±[2··(-1021)·2··(-1):2··(+1024)·(1-2··(-116))] | b#fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1.0 | b#sssssssssss | ±       |
| 最大数   | ±2··(+1024)·(1-2··(-116))                      | b#11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111.0 | b#01111111111 | ±       |
|          |                                                | 硬件中断                                                     |               |         |
| 无穷大   | ±∞                                             | b#ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff.0 | b#11111111111 | ±       |
| 非数     | ±ϰ                                             | b#11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111.0 | b#11111111111 | ±       |


IEEE浮点数特殊值：
                                ±ϰ
-∞ < -maxi < -mini < -unno < -0 == +0 < +unno < +mini < +maxi < +∞

IEEE浮点数的特殊运算：无效运算、上溢运算、下溢运算、零值运算、舍入运算。
IEEE浮点数采用筛选法处理特殊值（非通用标准），特殊值包括±ϰ|±∞|±unno|±0。
其零：任一数运算ϰ得ϰ，ϰ运算任一数得ϰ。
其一：-∞加上+∞得ϰ，任一数加上∞得∞，任一数加上0得任一数，∞加上任一数得∞，0加上任一数得任一数。
其二：+∞减去+∞得ϰ，任一数减去∞得∞，任一数减去0得任一数，∞减去任一数得∞，0减去任一数得任一数。
其三：0乘以∞得ϰ，任一数乘以∞得∞，∞乘以0得ϰ，任一数乘以0得0，∞乘以任一数得∞，0乘以任一数得0。
其四：∞除以∞得ϰ，任一数除以∞得0，任一数除以0得ϰ，∞除以任一数得∞，0除以任一数得0。


Do语言浮点数特殊值：
                                 ±ϰ
-∞ < -maxi < -mini < -epsi < -0 == +0 < +epsi < +mini < +maxi < +∞

Do语言浮点数的特殊运算：无效运算、极值运算、零值运算、舍入运算。
Do语言浮点数采用筛选法处理特殊值（准通用标准），特殊值包括±ϰ|±∞|±0。
其零：任一数运算ϰ得ϰ，ϰ运算任一数得ϰ。
其一：-∞加上+∞得ϰ，任一数加上∞得∞，∞加上任一数得∞。
其二：+∞减去+∞得ϰ，任一数减去∞得∞，∞减去任一数得∞。
其三：0乘以∞得ϰ，任一数乘以∞得∞，∞乘以0得ϰ，∞乘以任一数得∞。
其四：∞除以∞得ϰ，任一数除以∞得0，任一数除以0得ϰ，∞除以任一数得∞。


浮点数的大小比较运算：按照数域符、移码域、尾码域作字典序比较。

浮点数加法运算：
步骤零，特值检测。
步骤一，阶码对齐，小阶尾码移位小数点对齐大阶。当阶码的差值大于运算的位数时，则运算无效果。
步骤二，尾码相加。
步骤三，规范移位，结果尾码移位使小数点规范化。
步骤四，异常判断。

浮点数减法运算：
步骤零，特值检测。
步骤一，阶码对齐，小阶尾码移位小数点对齐大阶。当阶码的差值大于运算的位数时，则运算无效果。
步骤二，尾码相减。
步骤三，规范移位，结果尾码移位使小数点规范化。
步骤四，异常判断。

浮点数乘法运算：
步骤零，特值检测。
步骤一，阶码相加。
步骤二，尾码相乘。
步骤三，规范移位，结果尾码移位使小数点规范化。
步骤四，异常判断。

浮点数除法运算：
步骤零，特值检测。
步骤一，阶码相减。
步骤二，尾码相除。
步骤三，规范移位，结果尾码移位使小数点规范化。
步骤四，异常判断。

浮点数的舍入方式：
其零，四舍五入。
其一，向±0舍入。
其二，向+∞舍入。
其三，向-∞舍入。

十进制小数转换为二进制小数的方法：
#d0.125   => #b0.001
0.125 · 2 => 0.25
0.25  · 2 => 0.5
0.5   · 2 => 1.0
#b0.0 + #b0.00 + #b0.001 => #b0.001

二进制小数转换为十进制小数的方法：
#b0.001     => #d0.125
0 · 2··(-1) => 0.0
0 · 2··(-2) => 0.00
0 · 2··(-3) => 0.125
#d0.0 + #d0.00 + #d0.125 => #d0.125

### Do语言的基码与颜色

相关关键词：基码、ERGB颜色

Do语言原生支持6种常用的基码及其编解码，并内置实现其打印格式。

| 缩略 | 基码   | 进制       | 单词                                 | UCS字符                                                      |
| ---- | ------ | ---------- | ------------------------------------ | ------------------------------------------------------------ |
| b    | base02 | 二进制     | binary                               | 01                                                           |
| d    | base10 | 十进制     | decimal                              | 0123456789                                                   |
| h    | base16 | 十六进制   | hexadecimal                          | 0123456789ABCDEF                                             |
| f    | base32 | 三十二进制 | [duofastimal](⌊fast⌉取自⌊steadfast⌉) | 0123456789ABCDEFGHIJKLMNOPQRSTUV                             |
| s    | base64 | 六十四进制 | quasexagesimal                       | 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz∞ϰ |
| c    | ergb   | ERGB编码   |                                      |                                                              |

Do语言的颜色编码采用ERGB颜色系统，ERGB颜色系统是一种位宽40bites的透明的均匀的增色的颜色系统。

pack Color
    auto _operation ⊏ bite:2 {0};  !! 采用base02基码，可表示4种操作类型
    auto _energy    ⊏ bite:8 {0};  !! 采用base16基码
    auto _red       ⊏ bite:10{0};  !! 采用base32基码
    auto _green     ⊏ bite:10{0};  !! 采用base32基码
    auto _blue      ⊏ bite:10{0};  !! 采用base32基码

| 色光三原色 | 二进制                                         | ERGB             | BGRE             |
| ---------- | ---------------------------------------------- | ---------------- | ---------------- |
| 红色       | b#00_11111111_1111111111_0000000000_0000000000 | c#00_FF_VV_00_00 | #c00_00_VV_FF_00 |
| 绿色       | b#00_11111111_0000000000_1111111111_0000000000 | c#00_FF_00_VV_00 | #c00_VV_00_FF_00 |
| 蓝色       | b#00_11111111_0000000000_0000000000_1111111111 | C#00_FF_00_00_VV | #cVV_00_00_FF_00 |
|            |                                                |                  |                  |
| 色光三原色 | 二进制                                         | ARGB             | BGRA             |
| 红色       | #b11111111_11111111_00000000_00000000          | #hFFFF0000       | h#0000FFFF       |
| 绿色       | #b11111111_00000000_11111111_00000000          | #hFF00FF00       | h#00FF00FF       |
| 蓝色       | #b11111111_00000000_00000000_11111111          | #hFF0000FF       | h#FF0000FF       |

操作b#00是前景色融合背景色
E⌄(fb)  ⊏ E⌄(f) + E⌄(b) · (1 - E⌄(f))                  ;  !! E 值可以调换前景色与背景色
Cr⌄(fb) ⊏ E⌄(f) · Cr⌄(f) + E⌄(b) · (1 - E⌄(f)) · Cr⌄(b);  !! Cr值不可调换前景色与背景色
Cg⌄(fb) ⊏ E⌄(f) · Cg⌄(f) + E⌄(b) · (1 - E⌄(f)) · Cg⌄(b);  !! Cg值不可调换前景色与背景色
Cb⌄(fb) ⊏ E⌄(f) · Cb⌄(f) + E⌄(b) · (1 - E⌄(f)) · Cb⌄(b);  !! Cb值不可调换前景色与背景色

操作b#10是前景色覆盖背景色
E⌄(fb)  ⊏ E⌄(f) ;  !! E 值不可调换前景色与背景色
Cr⌄(fb) ⊏ Cr⌄(f);  !! Cr值不可调换前景色与背景色
Cg⌄(fb) ⊏ Cg⌄(f);  !! Cg值不可调换前景色与背景色
Cb⌄(fb) ⊏ Cb⌄(f);  !! Cb值不可调换前景色与背景色

操作b#01是前景色浮雕背景色
E⌄(fb)  ⊏ 0 < E⌄(f) ? E⌄(f)  : E⌄(b) ;  !! E 值不可调换前景色与背景色
Cr⌄(fb) ⊏ 0 < E⌄(f) ? Cr⌄(f) : Cr⌄(b);  !! Cr值不可调换前景色与背景色
Cg⌄(fb) ⊏ 0 < E⌄(f) ? Cg⌄(f) : Cg⌄(b);  !! Cg值不可调换前景色与背景色
Cb⌄(fb) ⊏ 0 < E⌄(f) ? Cb⌄(f) : Cb⌄(b);  !! Cb值不可调换前景色与背景色

操作b#11是前景色镂刻背景色
E⌄(fb)  ⊏ 0 < E⌄(b) ? E⌄(f)  : E⌄(b) ;  !! E 值不可调换前景色与背景色
Cr⌄(fb) ⊏ 0 < E⌄(b) ? Cr⌄(f) : Cr⌄(b);  !! Cr值不可调换前景色与背景色
Cg⌄(fb) ⊏ 0 < E⌄(b) ? Cg⌄(f) : Cg⌄(b);  !! Cg值不可调换前景色与背景色
Cb⌄(fb) ⊏ 0 < E⌄(b) ? Cb⌄(f) : Cb⌄(b);  !! Cb值不可调换前景色与背景色

### Do语言的基本类型与字面量

相关关键字：iptr、bite、byte、char、uin4、uin8、int1、int2、int4、int8、num4、num8、com4、com8、bool、pack、sole、auto
相关关键词：根本数值类型、根本类型、基本类型

常规四则算术运算包括：加法、减法、乘法、除法。
常规五则算术运算包括：加法、减法、乘法、除法、幂法。
常规六则算术运算包括：加法、减法、乘法、除法、幂法、模法。
整数满足常规六则算术运算，实数满足常规六则算术运算，复数满足常规五则算术运算，四元数不满足常规四则算术运算。

Do语言的根本数值类型包括：地址型、位域型、字节型、字符型、无符号整型、有符号整型、浮点型、复数型。
Do语言的根本类型包括：根本数值类型、布尔型、组合体、共用体，以及根本类型的串类型。串类型只支持一维的根本类型。
Do语言的基本类型包括：根本类型，以及根本类型的数组类型。数组类型可支持多维的任意类型。
Do语言的根本数值类型的常规算术运算都是向零截断，而非向下截断。
Do语言的根本类型都没有内置的方法，非根本类型都具有内置的方法。

Do语言的地址型包含两个成员变量_address与_offset，地址型的构造方法正好有两个输入位置实参。
Do语言的复数型包含两个成员变量_existent与_practical，复数型的构造方法正好有两个输入位置实参。

Do语言的组合体不允许继承与派生，不允许包含内置的方法，允许组合根本类型，其成员变量都是公有可读写的。组合体本身是根本类型，组合体的构造方法可以有多个输入关键实参。
Do语言的共用体不允许继承与派生，不允许包含内置的方法，允许共用根本类型，其成员变量都是公有可读写的。共用体本身是根本类型，共用体的构造方法最多有一个输入关键实参。

type Main
    !! Do语言的组合体与共用体的示例
    pack Outer
        pack Inner
            auto _abc ⊏ uin8{0};
            auto _def ⊏ num8{0.0};
            auto _ghi ⊏ char#5{
                'a', 'b', 'c'
            };
        sole Union
            auto _one ⊏ uin8{0};
            auto _two ⊏ num8{0.0};
            auto _tri ⊏ char#5{
                'a', 'b', 'c'
            };
        auto _inner ⊏ Inner{abc ⊏ 1, def ⊏ 1.0, ghi ⊏ char#5{'d', 'e', 'f'}};
        auto _union ⊏ Union{two ⊏ 1.0};

    !! Do语言的组合体与共用体的便捷示例
    pack Outer
        auto _inner ⊏ pack Inner{abc ⊏ 1, def ⊏ 1.0, ghi ⊏ char#5{'d', 'e', 'f'}}
            auto _abc ⊏ uin8{0};
            auto _def ⊏ num8{0.0};
            auto _ghi ⊏ char#5{
                'a', 'b', 'c'
            };
        auto _union ⊏ sole Union{two ⊏ 1.0}
            auto _one ⊏ uin8{0};
            auto _two ⊏ num8{0.0};
            auto _tri ⊏ char#5{
                'a', 'b', 'c'
            };

    func _Complex〈〉
        auto complex ⊏ com8{1234.0, 5678.0};
        Console._Print〈complex\_existent〉;
        Console._Print〈complex\_practical〉;

    func _Chunk〈〉
        func ____Func〈chunk: &char#leng〉
            loop(auto ordi ⊏ 0; ordi < leng)
                Console._Print〈($chunk + ordi).〉;
                ordi += 1;

        auto inner ⊏ Outer.Inner{};
        ____Func〈inner\_ghi〉;

Do语言可以根据字面量生成对应的基本类型实例，而且当基本类型的构造方法输入实参为字面量时，编译器将优化直接构造基本类型实例。

type Main
    !! Do语言的字面量的示例
    func _Literal〈〉
        auto signed_positive        ⊏ #h000A;     !! 长度为2bytes，因此生成int2类型的实例
        auto signed_negative        ⊏ #h-000A;    !! 长度为2bytes，因此生成int2类型的实例
        auto unsigned               ⊏ #h$000A;    !! 长度为2bytes，因此生成uin2类型的实例
        auto character_chunk        ⊏ 'A';
        auto character_array        ⊏ !'A';
        auto character_chunk_format ⊏ h#'A000';
        auto character_array_format ⊏ !h#'A000';

    !! Do语言的构造方法采用字面量的示例
    func _Constructor_Literal〈〉
        auto numeric ⊏ (uin8)#h$0A;  !! 根据字面量#h0A生成byte类型的实例，再类型转换为uin8类型的实例
        auto literal ⊏ uin8{#h$0A};  !! 直接构造uin8类型的实例，其初始值为字面量#h$0A

### Do语言的位域类型与地理戳

相关关键字：bite
相关的类型：Data、Time、Zone、DateTime、DateTimeZone、DateTimeZoneSite、Geographic、Geocentric、GeographicGeocentric、Spherical、Cube
相关关键词：位域型、自然历、公零历、公元历、地理戳、时间戳、坐标戳

Do语言的位域与C/C++语言的位域存在差别：
00. Do语言的变量无需考虑内存边界对齐，C/C++语言的变量须要考虑内存边界对齐。
01. Do语言的位域类型不能是有符号整型，C/C++语言的位域类型允许是有符号整型。
02. Do语言的位域的总大小是所有的位域考虑最少节数的总大小，C/C++语言的位域的总大小是所有的位域考虑类型节数的总大小。

C/C++语言的位域的规则：
00. 若前位域与本位域的类型大小相同，且本位域偏移量与本位域长度之和小于本位域类型的大小，则本位域偏移量不变，后位域偏移量为本位域偏移量加上本位域长度。
01. 若前位域与本位域的类型大小相同，且本位域偏移量与本位域长度之和超出本位域类型的大小，则本位域另起下一内存对齐处，本位域偏移量置零。
02. 若前位域与本位域的类型大小不同，则本位域另起下一内存对齐处，本位域偏移量置零。

Do语言的位域的规则：
00. Do语言的位域bite类型是无符号64位整型。
01. 若本位域偏移量与本位域长度之和小于本位域类型的大小，则本位域偏移量不变，后位域偏移量为本位域偏移量加上本位域长度。
02. 若本位域偏移量与本位域长度之和超出本位域类型的大小，则本位域另起下一节，本位域偏移量置零。

// C/C++语言的位域的示例
#pragma pack(1)
struct Bits {
    int8_t  _a:7;  // &0bytes:0bites
    int16_t _b:2;  // &1bytes:0bites
    int8_t  _c:3;  // &3bytes:0bites
};
#pragma unpack

!! Do语言的位域的示例
pack Bits
    auto _a ⊏ bite:7{0};  !! $0bytes:0bites
    auto _b ⊏ bite:2{0};  !! $0bytes:7bites
    auto _c ⊏ bite:3{0};  !! $0bytes:9bites


公元历也即格里高利历Gregorian Calendar，是国际通用的标准历法，由教皇格里高利十三世于1582年颁行，以耶稣诞生之年作为公元元年。
自然历也即公零历，是Do语言的内置标准历法，以自然历以及Do语言的创造者的诞生之年也即公元1993年作为自然历零年。

Do语言的地理时间戳采用自然历时间戳格式。
[公元历当地时间戳格式，变长精确度表示]
±YYYY/MM/DD⊥hh:mm:ss.tttt&+ZZ:zz:dd.oooo$ZZ:zz:dd.oooo@Site
伦敦当地时间2025/12/04⊥12:00:00.1234&+08:00:00.0000$00:00:00.0000@ShangHai
[公元历标准时间戳格式，变长精确度表示]
±YYYY/MM/DD⊥hh:mm:ss.tttt&-ZZ:zz:dd.oooo$ZZ:zz:dd.oooo@Site
上海标准时间2025/12/04⊥20:00:00.1234&-08:00:00.0000$00:00:00.0000@ShangHai
[自然历当地时间戳格式，变长精确度表示]
±YYYY/WW/DD⊥hh:mm:ss.tttt&+ZZ:zz:dd.oooo$ZZ:zz:dd.oooo@Site
伦敦当地时间2025/12/04⊥12:00:00.1234&+08:00:00.0000$00:00:00.0000@ShangHai
[自然历标准时间戳格式，变长精确度表示]
±YYYY/WW/DD⊥hh:mm:ss.tttt&-ZZ:zz:dd.oooo$ZZ:zz:dd.oooo@Site
上海标准时间2025/12/04⊥20:00:00.1234&-08:00:00.0000$00:00:00.0000@ShangHai

type Date
    pack Pack
        auto __calendar   ⊏ bite:3 {0};  !! 可表示8种历法，{自然历, 公元历, 农历, 其它, ...}
        auto __day        ⊏ bite:5 {0};  !! [0:30]天，2··(5)=32
        auto __week_month ⊏ bite:6 {0};  !! [0:51]周，2··(6)=64
        auto __year       ⊏ bite:17{0};  !! [0:131071]年，2··(17)=131072
        auto __elapsed    ⊏ bite:1 {0};  !! 基准年往后是正数，基准年往前是负数
        !! 4bytes，32bites
    prop __date ⊏ Pack{};

type Time
    pack Pack
        auto __precision  ⊏ bite:2 {0};  !! 可表示4种精确度，{10··(+0)秒, 10··(-4)秒, 10··(-8)秒, 10··(-10)秒}
        auto __tune       ⊏ bite:34{0};  !! 精确度最高可达10··(-10)秒，此字段根据精确度要求而解释不同
        auto __second     ⊏ bite:6 {0};  !! [0:59]秒，2··(6)=64
        auto __minute     ⊏ bite:6 {0};  !! [0:59]分，2··(6)=64
        auto __hour       ⊏ bite:5 {0};  !! [0:23]时，2··(5)=32
        auto __source     ⊏ bite:3 {0};  !! 可表示8种来源，{本机, 网络, 卫星, 其它, ...}
        !! 7bytes，56bites
    prop __time ⊏ Pack{};

type Zone
    pack Pack
        auto __accuracy   ⊏ bite:3 {0};  !! 可表示8种精确度，{时, 分, 秒, 10··(-4)秒, 10··(-8)秒, 10··(-10)秒}
        auto __offset     ⊏ bite:34{0};  !! 精确度最高可达10··(-10)秒，此字段根据精确度要求而解释不同
        auto __deviation  ⊏ bite:6 {0};  !! [0:59]秒，2··(6)=64
        auto __zenith     ⊏ bite:6 {0};  !! [0:59]分，2··(6)=64
        auto __zone       ⊏ bite:5 {0};  !! [0:23]时，2··(5)=32
        auto __clockwise  ⊏ bite:1 {0};  !! 左手旋顺时针是正数，右手旋逆时针是负数
        auto __meridian   ⊏ bite:1 {0};  !! 自然历是上海子午线，公元历是伦敦子午线
        !! 7bytes，56bites
    prop __zone ⊏ Pack{};

type DateTime: Date, Time
    !! 4bytes + 7bytes = 11bytes

type DateTimeZone: Date, Time, Zone
    !! 4bytes + 7bytes + 7bytes = 18bytes

type DateTimeZoneSite: Date, Time, Zone
    prop __site ⊏ Zone.Pack{};
    !! 4bytes + 7bytes + 7bytes + 7bytes = 25bytes

Do语言的地理坐标戳采用自然历坐标戳格式。
[自然历标准坐标戳格式，变长精确度表示]
°LLL.LLLL⊤°lll.llll&±aaaa.aaaa$SSSS.SSSS@±RRRR.RRRR±IIII.IIII±AAAA.AAAA
上海当地坐标°0.0000⊤°0.0000&0.0000$????.????
[自然历当地坐标戳格式，变长精确度表示]
°LLL:MM:SS.TTTT⊤°lll:mm:ss.tttt&±aaaa.aaaa$SSSS.SSSS@±RRRR.RRRR±IIII.IIII±AAAA.AAAA
上海当地坐标°0:0:0.0000⊤°0:0:0.0000&0.0000$????.????
[自然历地心坐标戳格式，变长精确度表示]〈经度地心角ϕ，纬度南极角ψ，地心基准距γ⌄a，地心基准径γ⌄s，直角横轴距u⌄r，直角溯轴距u⌄i，直角升轴距u⌄a〉
u⌄r = (γ⌄s + γ⌄a) · sine〈ψ〉· cosi〈ϕ〉;
u⌄i = (γ⌄s + γ⌄a) · sine〈ψ〉· sine〈ϕ〉;
u⌄a = (γ⌄s + γ⌄a) · cosi〈ψ〉;

type Geographic
    pack Pack
        auto __resolution ⊏ bite:4{0};  !! 可表示16种精确度
        auto __accuracy   ⊏ bite:4{0};  !! 可表示16种精确度
        auto __longitude  ⊏ num8{0.0};  !! 角进制是角度degree，取值范围[3.45·10··(-77) : 1.16·10··(+77)]，精确度是十进制15位
        auto __latitude   ⊏ num8{0.0};  !! 角进制是角度degree，取值范围[3.45·10··(-77) : 1.16·10··(+77)]，精确度是十进制15位
        auto __surface    ⊏ num8{0.0};  !! 单位是尺   rule  ，取值范围[3.45·10··(-77) : 1.16·10··(+77)]，精确度是十进制15位
        auto __altitude   ⊏ num8{0.0};  !! 单位是尺   rule  ，取值范围[3.45·10··(-77) : 1.16·10··(+77)]，精确度是十进制15位
        !! 33bytes
    prop __geographic ⊏ Pack{};

type Geocentric
    pack Pack
        auto __form      ⊏ bite:4{0};  !! 可表示16种来源，{理论值, 测量值, 计算值, 设定值, 变换值, 校准值, 统计值, ...}
        auto __precision ⊏ bite:4{0};  !! 可表示16种精确度
        auto __reverse   ⊏ num8{0.0};  !! 单位是尺rule，取值范围[3.45·10··(-77) : 1.16·10··(+77)]，精确度是十进制15位
        auto __inverse   ⊏ num8{0.0};  !! 单位是尺rule，取值范围[3.45·10··(-77) : 1.16·10··(+77)]，精确度是十进制15位
        auto __anti      ⊏ num8{0.0};  !! 单位是尺rule，取值范围[3.45·10··(-77) : 1.16·10··(+77)]，精确度是十进制15位
        !! 25bytes
    prop __geocentric ⊏ Pack{};

type GeographicGeocentric: Geographic, Geocentric
    pack Pack
        auto __degree     ⊏ bite:1{0};   !! 可表示2种角进制，{角度制, 弧度制}
        auto __unit       ⊏ bite:1{0};   !! 可表示2种单位制，{自然历单位制, 国际单位制}
        auto __coordinate ⊏ bite:15{0};  !! 可表示32768种天球坐标系，{地理坐标系, 地平坐标系, 赤道坐标系, 黄道坐标系, ...}
        auto __measure    ⊏ bite:15{0};  !! 可表示32768种测量系统，{北斗卫星导航系统, GPS全球定位系统, ...}
        !! 4bytes
    prop __measurement ⊏ Pack{};
    !! 33bytes + 25bytes + 4bytes = 62bytes

type Spherical  !! Do语言的表层采用角度制，底层当然是弧度制
    pack Pack
        auto __central   ⊏ num8{0.0};  !! 角进制是角度degree
        auto __antarctic ⊏ num8{0.0};  !! 角进制是角度degree
        auto __distance  ⊏ num8{0.0};  !! 单位是尺   rule
        !! 24bytes
    prop __spherical ⊏ Pack{};

type Cube       !! Do语言规范约定，类体命名为名词时成员字段使用定点型，类体命名为形容词时成员字段使用浮点型
    pack Pack
        auto __reverse ⊏ int8{0};  !! 单位是尺rule
        auto __inverse ⊏ int8{0};  !! 单位是尺rule
        auto __anti    ⊏ int8{0};  !! 单位是尺rule
        !! 24bytes
    prop __cube ⊏ Pack{};

### Do语言的泛型模板

Do语言的泛型模板采用两遍编译方案，
第一遍预编译会对泛型模板的形参做语法检查，生成模板的编译器内部表示，第二遍实编译根据泛型模板的实参进行实例化，生成独立可执行的机器指令。Do语言的泛型模板实例化是编译期多态机制，Do语言的编译器支持调试泛型模板。

Do语言的泛型模板的形参支持与继承关系以及或继承关系，与继承关系以及或继承关系可以同时混用。

Do语言规范规定，泛型模板的形参为任意类型时以大写字母开头以下划线结尾，形参为字面量时以小写字母开头以下划线结尾。Do语言的类体的成员变量以及泛型模板的实参必须是异步类型，包括根本类型、类体类型、指针类型、引用类型，由于别名类型是同步类型，因此别名类型不能作为泛型模板的实参。

Do语言的泛型模板不支持默认实参，当泛型模板的实参采用自动推断时须要使用auto关键字占位。Do语言的泛型类型模板以及泛型方法模板都支持模板实参特例化，Do语言允许非泛型类型模板的普通类型与泛型类型模板同时并存，也允许非泛型方法模板的普通方法与泛型方法模板同时并存。

type Main
    !! Do语言的泛型模板的形参支持与继承关系以及或继承关系的示例
    type Covariant(And_: Base0 ? Base1, Or_: Base2 | Base3)
        prop _and ⊏ And_{};
        prop _or  ⊏ Or_{};

    !! Do语言的泛型模板采用字面量的示例
    type Array(Type_, dimension_:> uin8)        !! :>表示编译期字面量
        prop __root       ⊏ ($Type_)null;
        prop __capacity   ⊏ uin8{0};
        prop __size       ⊏ uin8{0};
        prop __dimensions ⊏ uin8#dimension_{};  !! 串类型只支持一维的根本类型

    !! Do语言的泛型模板采用或继承关系的示例
    take Array(Numerical_, 1) = Vector(Numerical_);
    type Vector(Numerical_: int8 | uin8 | num8 | com8)
        prop __root     ⊏ ($Numerical_)null;
        prop __capacity ⊏ uint8{0};
        prop __size     ⊏ uint8{0};

        ctor &Vector{capacity: uint8}
            __root     ⊏ ($Numerical_)make Numerical_#capacity{};
            __capacity ⊏ capacity;
            __size     ⊏ 0;

        !! Do语言的构造方法是泛型方法模板的示例
        @apply: Vector(Datum_).prop
        ctor &Vector(Datum_){that: &Vector(Datum_)}
            __root     ⊏ ($Numerical_)make Numerical_#(that\__capacity){};
            __capacity ⊏ that\__capacity;
            loop(auto ordi ⊏ 0; ordi < that\__size)
                (__root + ordi). ⊏ (Numerical_)((that\__root + ordi).);
                ordi +⊏ 1;
            __size     ⊏ that\__size;

        !! Do语言的非泛型方法模板的普通方法的示例
        func _Print〈stream: &Stream〉
            auto repr ⊏ !'';
            repr +⊏ Char{__size, Char.Enum._auto_type};
            repr +⊏ !"'";
            loop(auto ordi ⊏ 0; ordi < __size)
                repr +⊏ Char{(__root + ordi)., Char.Enum._auto_type};
                ordi +⊏ 1;
            rept +⊏ !"'";
            stream._Print〈repr〉;

        !! Do语言的泛型方法模板的示例
        func _Print(Stream_)〈stream: &Stream_〉
            auto repr ⊏ !'';
            repr +⊏ Char{__size, Char.Enum._auto_type};
            repr +⊏ !"'";
            loop(auto ordi ⊏ 0; ordi < __size)
                repr +⊏ Char{(__root + ordi)., Char.Enum._auto_type};
                ordi +⊏ 1;
            rept +⊏ !"'";
            stream._Print〈repr〉;

        !! Do语言的泛型方法模板的模板实参特例化的示例
        func _Print(Stream_ = Console)〈stream: &Stream_〉
            auto repr ⊏ !'';
            repr +⊏ Char{__size, Char.Enum._auto_type};
            repr +⊏ !"'";
            loop(auto ordi ⊏ 0; ordi < __size)
                repr +⊏ Char{(__root + ordi)., Char.Enum._auto_type};
                ordi +⊏ 1;
            rept +⊏ !"'";
            stream._Print〈repr〉;

    main Main{}
        auto vector        ⊏ Vector(num8){};
        auto copy_explicit ⊏ Vector(uin8)(int8){vector};  !! 显式指定泛型方法模板的实参
        auto copy_deduce   ⊏ Vector(uin8)(take){vector};  !! 自动推断泛型方法模板的实参

        auto printer ⊏ Printer{};
        vector._Print〈printer〉;            !! 调用非泛型方法模板的普通方法
        vector._Print(Printer)〈printer〉;   !! 调用泛型方法模板
        vector._Print(Console)〈Console.〉;  !! 调用泛型方法模板的模板实参特例化
        vector._Print(take)〈Console.〉;     !! 自动推断泛型方法模板的实参

### Do语言的数组类型

相关关键字：byte、char、take
相关的类型：Array(Type_, dimension_)、Vector(Numerical_)、Matrix(Numerical_)、Byte、Char、Init(Type_)
相关关键词：多维数组、向量、矩阵、字节数组、字符数组、初始化数组

Do语言的数组类型是Do语言的内置实现。
Do语言的数组类型包括：多维数组Array(Type_, dimension_)、一维向量Vector(Numerical_)、二维矩阵Matrix(Numerical_)、一维字节数组Byte、一维字符数组Char、一维初始化数组Init(Type_)。

Do语言的Vector(Numerical_)与Matrix(Numerical_)与Byte与Char与Init(Type_)都是泛型模板Array(Type_, dimension_)的特化类型。
Do语言的Vector(Numerical_)与Matrix(Numerical_)具有矩阵运算相关的方法，Byte与Char具有串操作相关的方法，Init(Type_)根据元素类型由编译器生成。
Do语言的数组类型全部采用运行时动态扩增容量。

Do语言的方法不支持变长参数列表，变长参数列表可以由数组类型代替。

Do语言的数组类型有两种表示序：表格序、矩阵序。
Do语言的数组类型的表格序，数据的排列顺序是从左往右、从上往下。
Do语言的数组类型的矩阵序，数据的排列顺序是从左往右、从下往上。
Do语言的数组类型的下标语法是array[0, 1, 2, 3]，而不是array[0][1][2][3]。
Do语言的数组类型的切片语法是array[init0:stop0:step0, init1:stop1:step1, init2:stop2:step2]，其中init、stop、step都允许是可映射到数组下标的负整数。

type Main
    take Array(Numerical_, 1) = Vector(Numerical_);
    take Array(Numerical_, 2) = Matrix(Numerical_);
    take Array(byte, 1) = byte[];
    take byte[] = Byte;
    take Array(char, 1) = char[];
    take char[] = Char;

    func _Buffer〈〉
        auto buffer_0 ⊏ make byte[0]{};       !! buffer_0的类型是$(byte[])
        auto buffer_4 ⊏ make byte[4]{};       !! buffer_4的类型是$(byte[])
        buffer_0  ⊏ buffer_4;                 !! 赋值指针
        buffer_0. ⊏ buffer_4.;                !! 复制数组

        auto buffer_0_0 ⊏ make byte[0, 0]{};  !! buffer_0_0的类型是$(byte[,])
        auto buffer_4_4 ⊏ make byte[4, 4]{};  !! buffer_4_4的类型是$(byte[,])
        buffer_0_0  ⊏ buffer_4_4;             !! 赋值指针
        buffer_0_0. ⊏ buffer_4_4.;            !! 复制数组

        buffer_0  ⊏ buffer_0_0;               !! 编译期错误
        buffer_0. ⊏ buffer_0_0.;              !! 编译期错误

    !! Do语言的数组采用表格序初始化
    func _Initialize_Sheet〈〉
        auto array_3_2_1_3_2 ⊏ int8[3, 2, 1, 3, 2]{!{
            01, 02, 03,    !! [:,0,0,0,0]
            04, 05, 06,    !! [:,1,0,0,0]
            07, 08, 09,    !! [:,0,0,1,0]
            10, 11, 12,    !! [:,1,0,1,0]
            13, 14, 15,    !! [:,0,0,2,0]
            16, 17, 18,    !! [:,1,0,2,0]
            19, 20, 21,    !! [:,0,0,0,1]
            22, 23, 24,    !! [:,1,0,0,1]
            25, 26, 27,    !! [:,0,0,1,1]
            28, 29, 30,    !! [:,1,0,1,1]
            31, 32, 33,    !! [:,0,0,2,1]
            34, 35, 36,    !! [:,1,0,2,1]  !! 初始化数组的末项元素允许带逗号
        }};

        auto array_3_2_1_3_2 ⊏ int8[3, 2, 1, 3, 2]{![3, 2, 1, 3, 2]{
            [:,0,0,0,0]{ 01, 02, 03, },
            [:,1,0,0,0]{ 04, 05, 06, },
            [:,0,0,1,0]{ 07, 08, 09, },
            [:,1,0,1,0]{ 10, 11, 12, },
            [:,0,0,2,0]{ 13, 14, 15, },
            [:,1,0,2,0]{ 16, 17, 18, },
            [:,0,0,0,1]{ 19, 20, 21, },
            [:,1,0,0,1]{ 22, 23, 24, },
            [:,0,0,1,1]{ 25, 26, 27, },
            [:,1,0,1,1]{ 28, 29, 30, },
            [:,0,0,2,1]{ 31, 32, 33, },
            [:,1,0,2,1]{ 34, 35, 36, },    !! 初始化数组的末项元素允许带逗号
        }};

        auto matrix_3_2_1_3_2 ⊏ int8[3, 2, 1, 3, 2]{![3, 2, 1, 3, 2]{
            [:,:,0,0,0]{
                01, 02, 03;
                04, 05, 06;
            },
            [:,:,0,1,0]{
                07, 08, 09;
                10, 11, 12;
            },
            [:,:,0,2,0]{
                13, 14, 15;
                16, 17, 18;
            },
            [:,:,0,0,1]{
                19, 20, 21;
                22, 23, 24;
            },
            [:,:,0,1,1]{
                25, 26, 27;
                28, 29, 30;
            },
            [:,:,0,2,1]{
                31, 32, 33;
                34, 35, 36;                !! 初始化数组的末项元素允许带分号
            },                             !! 初始化数组的末项元素允许带逗号
        }};

    !! Do语言的数组采用矩阵序初始化
    func _Initialize_Matrix〈〉
        auto array_3_2_1_3_2 ⊏ int8[3, 2, 1, 3, 2]{#{
            34, 35, 36,    !! [:,1,0,2,1]
            31, 32, 33,    !! [:,0,0,2,1]
            28, 29, 30,    !! [:,1,0,1,1]
            25, 26, 27,    !! [:,0,0,1,1]
            22, 23, 24,    !! [:,1,0,0,1]
            19, 20, 21,    !! [:,0,0,0,1]
            16, 17, 18,    !! [:,1,0,2,0]
            13, 14, 15,    !! [:,0,0,2,0]
            10, 11, 12,    !! [:,1,0,1,0]
            07, 08, 09,    !! [:,0,0,1,0]
            04, 05, 06,    !! [:,1,0,0,0]
            01, 02, 03,    !! [:,0,0,0,0]  !! 初始化数组的末项元素允许带逗号
        }};

        auto array_3_2_1_3_2 ⊏ int8[3, 2, 1, 3, 2]{#[3, 2, 1, 3, 2]{
            [:,1,0,2,1]{ 34, 35, 36, },
            [:,0,0,2,1]{ 31, 32, 33, },
            [:,1,0,1,1]{ 28, 29, 30, },
            [:,0,0,1,1]{ 25, 26, 27, },
            [:,1,0,0,1]{ 22, 23, 24, },
            [:,0,0,0,1]{ 19, 20, 21, },
            [:,1,0,2,0]{ 16, 17, 18, },
            [:,0,0,2,0]{ 13, 14, 15, },
            [:,1,0,1,0]{ 10, 11, 12, },
            [:,0,0,1,0]{ 07, 08, 09, },
            [:,1,0,0,0]{ 04, 05, 06, },
            [:,0,0,0,0]{ 01, 02, 03, },    !! 初始化数组的末项元素允许带逗号
        }};

        auto matrix_3_2_1_3_2 ⊏ int8[3, 2, 1, 3, 2]{#[3, 2, 1, 3, 2]{
            [:,:,0,2,1]{
                34, 35, 36;
                31, 32, 33;
            },
            [:,:,0,1,1]{
                28, 29, 30;
                25, 26, 27;
            },
            [:,:,0,0,1]{
                22, 23, 24;
                19, 20, 21;
            },
            [:,:,0,2,0]{
                16, 17, 18;
                13, 14, 15;
            },
            [:,:,0,1,0]{
                10, 11, 12;
                07, 08, 09;
            },
            [:,:,0,0,0]{
                04, 05, 06;
                01, 02, 03;                !! 初始化数组的末项元素允许带分号
            },                             !! 初始化数组的末项元素允许带逗号
        }};

    !! Do语言的数组切片的示例
    func _Slice〈〉
        auto slice_2_1_1_1_1 ⊏ array_3_2_1_3_2[0:3:2, 0:2:2, 0, 0, 0];

        !! 数组切片的等价过程
        !! loop(auto ordi0 ⊏ 0; init0 < stop0)
        !!     loop(auto ordi1 ⊏ 0; init1 < stop1)
        !!         slice_2_1_1_1_1[ordi0, ordi1, 0, 0, 0] = array[init0, init1, 0, 0, 0];
        !!         ordi1 +⊏ 1;
        !!         init1 +⊏ step1;
        !!     ordi0 +⊏ 1;
        !!     init0 +⊏ step0;

目前在中国大陆简体字区，也就是中华人民共和国，矩阵的⌊行⌉对应于英文单词Row，矩阵的⌊列⌉对应于英文单词Column，矩阵也称为行列式。矩阵的运算次序是行优先于列。但是在中国台湾繁体字区，也就是中华民国台湾省，矩阵的⌊行⌉对应于英文单词Column，矩阵的⌊列⌉对应于英文单词Row，矩阵应称为列行式。其实列行式也是不恰当的，因为在Do语言中矩阵的书写次序是从左往右从下往上。

出现这种文化差异的根源在于，中文的⌊行⌉表示书写顺序，中文的⌊列⌉表示书写方式。在古代中国的书写次序是从上往下从左往右，因此古代当铺的票据，一行数字是从上往下进行书写的。在现代中国的书写次序是从左往右从上往下，因此现代银行的票据，一行数字是从左往右进行书写的。

### Do语言的字节数组与字符数组

相关关键字：byte、char
相关的类型：Array(Numerical_, dimension_)、byte[]、char[]、Byte、Char
相关关键词：字节串、字节数组、字符串、字符数组

Do语言的源代码文件采用紧凑UCS编码，Do语言的终端命令行跟源代码文件保持一致，Do语言的内部编码采用码表UCS编码。
Do语言的字节串与字符串为根本类型，没有内置的方法。Do语言的字节数组与字符数组为基本类型，带有内置的方法。字节数组与字符数组支持类加无符号整数运算。
Do语言编辑器中字节串与字节数组采用紧凑UCS编码，使用去声号``为界定符，使用连续重复的数字符#为前后导界定符。
Do语言编辑器中字符串与字符数组采用码表UCS编码，不换行使用单引号''为界定符，换行使用双引号""为界定符，使用连续重复的数字符#为前后导界定符。

type Main
    type Type
        oper !〈format: !''〉⊏> Char               !! 操作符方法oper !〈〉，返回本实例的字节数组表示
            exit !'yet.';

    !! Do语言的字节串的示例
    func _Byte_Chunk〈〉
        auto chunk0  ⊏ `0123456789↩ABCDEF`;       !! 创建为byte#17类型
        auto chunk1  ⊏ 17`01234567↩89ABCDEF`;     !! 创建为byte#17类型
        auto chunk2  ⊏ ##`0123456789↩ABCDEF`##    !! 创建为byte#17类型
        auto chunk4  ⊏ h#`A0B0`;                  !! 十六进制字节串，UCS文本`AB`
        auto chunk5  ⊏ b#`0101000011010000`;      !! 二进制字节串  ，UCS文本`AB`
        auto chunk6  ⊏ #h`0B0A`;                  !! 十六进制字节串，UCS文本`AB`
        auto chunk7  ⊏ #b`0000101100001010`;      !! 二进制字节串  ，UCS文本`AB`

        auto pointer ⊏ make `0123456789↩ABCDEF`;  !! 创建为$byte#17类型

    !! Do语言的字节数组的示例
    func _Byte_Array〈〉
        auto array0   ⊏ !`0123456789↩ABCDEF`;             !! 创建为Byte类型，也即byte[]类型
        auto array1   ⊏ !17`0123456789↩ABCDEF`;           !! 创建为Byte类型，也即byte[]类型
        auto array2   ⊏ !##`0123456789↩ABCDEF`;           !! 创建为Byte类型，也即byte[]类型
        auto array4   ⊏ !h#`A0B0`;                         !! 十六进制字节数组，UCS文本!`AB`
        auto array5   ⊏ !b#`0101000011010000`;             !! 二进制字节数组  ，UCS文本!`AB`
        auto array6   ⊏ !#h`0B0A`;                         !! 十六进制字节数组，UCS文本!`AB`
        auto array7   ⊏ !#b`0000101100001010`;             !! 二进制字节数组  ，UCS文本!`AB`

        auto pointer  ⊏ make !`0123456789↩ABCDEF`;         !! 创建为$Byte类型，也即$(byte[])类型
        auto double   ⊏ array0 + 2;                        !! 调用操作符方法oper +〈uint8〉

        auto variable ⊏ Type{};
        auto array8   ⊏ !`variable = {!variable}`;         !! 创建为Byte类型，花括号{}为特殊字符，调用Byte.oper +〈Byte{!variable, Byte.enum._coded_into_compact}〉
        auto array9   ⊏ !##`I don't know `## + !variable;  !! 创建为Byte类型，调用Byte.oper +〈Byte{!variable, Byte.enum._coded_into_compact}〉

    !! Do语言的字符串的示例
    func _Char_Chunk〈〉
        auto chunk0  ⊏ '<widget>↩</widget>';                  !! 创建为char#18类型
        auto chunk1  ⊏ 18'<widget>'</widget>';                !! 创建为char#18类型
        auto chunk2  ⊏ ##'<widget>↩</widget>'##;              !! 创建为char#18类型
        auto chunk3  ⊏ ##"<widget>↩                           !! 换行可视化时换行符也显示
</widget>"##;                                                 !! 创建为char#18类型
        auto chunk4  ⊏ h#'A000B000';                          !! 十六进制字符串，UCS文本'AB'
        auto chunk5  ⊏ b#'01010000000000001101000000000000';  !! 二进制字符串  ，UCS文本'AB'
        auto chunk6  ⊏ #h'000B000A';                          !! 十六进制字符串，UCS文本'AB'
        auto chunk7  ⊏ #b'00000000000010110000000000001010';  !! 二进制字符串  ，UCS文本'AB'

        auto pointer ⊏ make '<widget>↩</widget>';             !! 创建为$char#18类型

    !! Do语言的字符数组的示例
    func _Char_Array〈〉
        auto array0   ⊏ !'<widget>↩</widget>';                  !! 创建为Char类型，也即char[]类型
        auto array1   ⊏ !18'<widget>'</widget>';                !! 创建为Char类型，也即char[]类型
        auto array2   ⊏ !##'<widget>↩</widget>'##;              !! 创建为Char类型
        auto array3   ⊏ !##"<widget>↩                           !! 换行可视化时换行符也显示
</widget>"##;                                                   !! 创建为Char类型
        auto array4   ⊏ !h#'A000B000';                          !! 十六进制字符数组，UCS文本!'AB'
        auto array5   ⊏ !b#'01010000000000001101000000000000';  !! 二进制字符数组  ，UCS文本!'AB'
        auto array6   ⊏ !#h'000B000A';                          !! 十六进制字符数组，UCS文本!'AB'
        auto array7   ⊏ !#b'00000000000010110000000000001010';  !! 二进制字符数组  ，UCS文本!'AB'

        auto pointer  ⊏ make !'<widget>↩</widget>';             !! 创建为$Char类型，也即$(char[])类型
        auto double   ⊏ string0 + 2;                            !! 调用操作符方法oper +〈uin8〉

        auto variable ⊏ Type{};
        auto array8   ⊏ !'variable = {!variable}';              !! 创建为Char类型，花括号{}为特殊字符，调用Char.oper +〈!variable〉
        auto array9   ⊏ !##'I don't know '## + !variable;       !! 创建为Char类型，调用Char.oper +〈!variable〉

!! Do语言字符数组类型的部分实现
take Array(char, 1) = char[];
take char[] = Char;
type Char
    post _Capacity ⊏> _capacity;
    post _Size     ⊏> _size;

    prop __root     ⊏ ($char)null;
    prop __capacity ⊏ int8{0};
    prop __size     ⊏ int8{0};

    oper []〈ordi: int8〉⊏ &char
        test((0 <= ordi < __size) = nega)
            cast Error{!'out_of_range'};
        exit (__root + ordi).;

    @apply: Char.prop
    oper =〈that: &Char〉⊏> bool
        test(__size ¬= that\__size)
            exit nega;
        loop(auto ordi ⊏ 0; ordi < __size ∧ (__root + ordi). = (that\__root + ordi).)
            ordi +⊏ 1;
        exit (ordi = __size);

    func ___Assign_Copy〈that: $char, size: int8〉⊏> bool
        !! 若本实例容量足够
        test(__size + size <= __capacity)
            loop(auto head ⊏ __root + size; auto ordi ⊏ 0; ordi < size)
                (head + ordi). ⊏ (that + ordi).;
                ordi +⊏ 1;
            __size +⊏ size;
            exit posi;
        !! 若本实例容量不够
        auto capacity ⊏ __size + size · 2;
        auto root     ⊏ ($char)make char#capacity{};  !! 此处char#capacity的编译期类型是char#0，运行时类型是char#capacity
        auto head     ⊏ root;
        loop(auto ordi ⊏ 0; ordi < __size)
            (head + ordi). ⊏ (__root + ordi).;
            ordi +⊏ 1;
        loop(auto ordi ⊏ 0; ordi < size)
            (head + ordi). ⊏ (that + ordi).;
            ordi +⊏ 1;
        free __root;
        __root ⊏ root;
        __capacity ⊏ capacity;
        __size +⊏ size;
        exit posi;

    oper +⊏〈that: &char#size〉⊏> &Char    !! !'one' +⊏ 'two'
        this.___Assign_Copy〈($char)$that, size〉;
        exit (this.);

    @apply: Char.prop
    oper +⊏〈that: &Char〉⊏> &Char         !! !'one' +⊏ !'two'
        this.___Assign_Copy〈that.__root, that.__size〉;
        exit (this.);

    oper +〈that: &Char〉⊏ Char            !! !'one' + !'two'
        auto temp ⊏ this.;
        temp +⊏ that;
        exit temp;

### Do语言的类型规则与值交换

相关关键字：auto、flex
相关关键词：类型、类体、变量、实例、指针、别名、引用、体访问、实访问、虚访问、解地址

Do语言的类型可划分为5种：根本类型、类体类型、指针类型、别名类型、引用类型。
Do语言的变量可划分为4种：实例、指针、别名、引用。
Do语言的值交换可划分为2种：实例交换、地址交换。

Do语言的类型定义数据的结构
Do语言的实例存储实际的数据。
Do语言的指针存储变量的地址。地址类型可当作整数类型，满足常规四则算术运算。
Do语言的别名存储变量的地址。别名用于绑定变量，别名变量以后不允许更改别名。
Do语言的引用存储组合体的地址，组合体存储变量的地址与变量的计数。引用用于计数变量，引用变量以后不允许更改引用。

类型的访问规则：
00. 对实例的体访问\，只限于访问当前层。
01. 对指针的实访问.，为自当前层向基底层最近访问，实访问是编译期机制。实访问可能有歧义，此时须要先将指针向基底转换到无歧义的层，然后再做实访问。
02. 对指针的虚访问:，为自具体层向基底层最近访问，虚访问是运行期机制。可虚访问的前提是可实访问，若实访问无歧义，则虚访问无歧义。
03. 对别名的访问将转换为对原变量的访问。
04. 对引用的访问将转换为对原地址的访问。
05. 成员方法与操作符方法的访问机制相同。
06. 对指针解地址则变量的类型将降低一级。

类型的折叠规则：
00. 指针可以有多级，对固态类型取指针得到指针，叠加指针类型不会类型折叠。
01. 别名最多有一级，对固态类型取别名得到别名，叠加别名类型发生类型折叠。
02. 引用最多有一级，对一级指针取引用得到引用，引用为瞬态类型不允许叠加。

类型的创建规则：
00. flex变量是弱类型，其它变量是强类型。强类型变量可以直接创建弱类型变量，弱类型变量须要借助显式类型转换才能创建强类型变量。
01. 实例、指针、别名为固态类型，引用为瞬态类型。固态类型不能通过瞬态方式创建，瞬态类型可以通过瞬态方式创建。
02. 实例、指针、引用为异步类型，别名为同步类型。类体的成员变量必须是异步类型，泛型模板的形参必须是异步类型。

类型的赋值规则：
00. 赋值给弱类型变量，变量的类型会被覆盖。
01. 赋值给强类型变量，变量的类型必须兼容。
02. 实有类型及其别名是类型兼容的，实有类型及其引用非类型兼容的。

类型的重载规则：
00. 弱类型不可重载，强类型才可重载。
01. 相同类型的相同级别不能同时重载，实例类型及其别名类型、一级指针类型及其别名类型及其引用类型、多级指针及其别名类型不能同时重载。
02. 同一个限定域中的标识名唯一确定，因此同一个限定域中的标签名唯一确定。

!! Do语言的类型规则的示例
type Main
    func _Type_Visit〈〉
        type Level0
            prop _memb ⊏ int8{0};          !! _memb的指纹是prop _memb{int8}
            func _Func〈〉                  !! _Func的指纹是func _Func〈〉
                Console._Print〈_memb〉;
            oper !〈format: !''〉⊏> Char    !! 操作符!的指纹是oper !〈Char〉⊏> Char
                exit !'Level0';
        type Level1: Level0
            ;
        type Level2: Level1
            prop _memb ⊏ int8{2};          !! _memb的指纹是prop _memb{int8}
            func _Func〈〉                  !! _Func的指纹是func _Func〈〉
                Console._Print〈_memb〉;
            oper !〈format: !''〉⊏> Char    !! 操作符!的指纹是oper !〈Char〉⊏> Char
                exit !'Level2';
        type Level3: Level2
            prop _memb ⊏ int8{3};          !! _memb的指纹是prop _memb{int8}
            func _Func〈〉                  !! _Func的指纹是func _Func〈〉
                Console._Print〈_memb〉;
            oper !〈format: !''〉⊏> Char    !! 操作符!的指纹是oper !〈Char〉⊏> Char
                exit !'Level3';

        auto concret ⊏ Level2{};           !! concret的类型是Level2
        auto alias   ⊏ &concret;           !! alias的类型是&Level2
        auto present ⊏ (&Level1)&concret;  !! present的类型是&Level1
        auto pointer ⊏ $concret;           !! pointer的类型是$Level2
        auto current ⊏ ($Level1)$concret;  !! current的类型是$Level1

        Console._Print〈level2 \_memb〉;    !! 打印输出数字2
        Console._Print〈alias  \_memb〉;    !! 打印输出数字2
        Console._Print〈present\_memb〉;    !! 打印输出数字0
        Console._Print〈pointer._memb〉;    !! 打印输出数字2
        Console._Print〈pointer:_memb〉;    !! 打印输出数字2
        Console._Print〈!pointer.〉;        !! 打印输出!'Level2'
        Console._Print〈current._memb〉;    !! 打印输出数字0
        Console._Print〈current:_memb〉;    !! 打印输出数字2
        Console._Print〈!current.〉;        !! 打印输出!'Level0'

    !! Do语言的类型折叠的示例
    func _Type_Folding〈〉
        auto entity            ⊏ Entity{};    !! entity的类型是Entity
        auto pointer           ⊏ $entity;     !! pointer的类型是$Entity
        auto alias             ⊏ &entity;     !! alias的类型是&Entity
        auto reference         ⊏ &&pointer;   !! reference的类型是&&$Entity
        auto pointer_pointer   ⊏ $pointer;    !! pointer_pointer的类型是$$Entity
        auto pointer_alias     ⊏ $alias;      !! pointer_alias的类型是$Entity，叠加别名类型发生类型折叠
        auto pointer_reference ⊏ $reference;  !! 编译期错误，引用为瞬态类型不允许叠加
        auto alias_pointer     ⊏ &pointer;    !! alias_pointer的类型是&$Entity
        auto alias_alias       ⊏ &&alias;     !! alias_alias的类型是&Entity，叠加别名类型发生类型折叠
        auto alias_reference   ⊏ &reference;  !! 编译期错误，引用为瞬态类型不允许叠加

    !! Do语言的类型创建与类型赋值的示例
    func _Type_Creation_Assignment〈〉
        auto stack                   ⊏ Entity{int:1, num:2.0};       !! stack的类型是Entity
        auto pointer_stack           ⊏ $stack;                       !! pointer_stack的类型是$Entity
        auto pointer_pointer_stack   ⊏ $pointer_stack;               !! pointer_pointer_stack的类型是$$Entity
        auto pointerpointer_stack    ⊏ $$stack;                      !! 语法期错误，固态类型不能通过瞬态方式创建
        auto alias_stack             ⊏ &stack;                       !! alias_stack的类型是&Entity
        auto reference_stack         ⊏ &&stack;                      !! 编译期错误，reference_stack的类型是&&Entity
        auto reference_pointer_stack ⊏ &&pointer_stack;              !! 运行期错误，reference_pointer_stack的类型是&&$Entity
        auto heap                    ⊏ make Entity{int:1, num:2.0};  !! heap的类型是$Entity
        auto alias_heap              ⊏ &heap;                        !! alias_heap的类型是&$Entity
        auto reference_heap          ⊏ &&heap;                       !! reference_heap的类型是&&$Entity

        alias_heap     ⊏ pointer_stack;    !! 编译正确，&$Entity类型与$Entity类型兼容
        alias_heap     ⊏ &pointer_stack;   !! 编译正确，&$Entity类型与&$Entity类型相同
        reference_heap ⊏ pointer_stack;    !! 编译错误，&&$Entity类型与$Entity类型不兼容
        reference_heap ⊏ &pointer_stack;   !! 编译错误，&&$Entity类型与&$Enity类型不兼容
        reference_heap ⊏ &&pointer_stack;  !! 编译正确，&&$Entity类型与&&$Entity类型相同

        auto take_heap ⊏ ($Heap)reference_heap;     !! 读取reference_heap引用的变量地址
        take_heap      ⊏ reference_heap\_Reset〈〉;  !! 重置reference_heap引用的变量地址，其引用计数保持不变
        free take_heap;

    !! Do语言的类型的示例
    func _Entity_Pointer_Alias_Reference〈〉
        auto stack                 ⊏ Entity{int:1, num:2.0};       !! stack的类型是Entity
        auto pointer_stack         ⊏ $stack;                       !! pointer_stack的类型是$Entity
        auto pointer_pointer_stack ⊏ $$pointer_stack;              !! pointer_pointer_stack的类型是$$Entity
        auto alias_stack           ⊏ &stack;                       !! alias_stack的类型是&Entity
        auto alias_pointer_stack   ⊏ &pointer_stack;               !! alias_pointer_stack的类型是&$Entity
        auto heap                  ⊏ make Entity{int:3, num:4.0};  !! heap的类型是$Entity
        auto pointer_heap          ⊏ $heap;                        !! pointer_heap的类型是$$Entity
        auto pointer_pointer_heap  ⊏ $pointer_heap;                !! pointer_pointer_heap的类型是$$$Entity
        auto alias_heap            ⊏ &heap;                        !! alias_heap的类型是&$Entity，当alias_heap超出限定域时不会自动执行free操作
        auto alias_pointer_heap    ⊏ &pointer_heap;                !! alias_pointer_heap的类型是&$$Entity
        auto reference_heap        ⊏ &&heap;                       !! reference_heap的类型是&&$Heap，当reference_heap超出限定域时会自动执行free操作

!! func _Entity_Pointer_Alias_Reference〈〉的运行栈
[#h..00] _trait_entity        ; {_bytes:16, _supers:0, [], ....}
[#h!!00] stack                ; {_concret:#h..00, Entity{_int:1, _num:2.0}}
[#h!!00] _concret             ; #h..00
[#h!!08]                      ; Entity{_int:1, _num:2.0}
[#h!!08] _int                 ; 1
[#h!!10] _num                 ; 2.0
[#h!!18] pointer_stack        ; Pointer{_address:#h!!00, _offset:8+0, _dynamic:#h..00}
[#h!!30] pointer_pointer_stack; Address{_address:#h!!18}
[#h!!38] alias_stack          ; Pointer{_address:#h!!00, _offset:8+0, _dynamic:#h..00}
[#h!!50] alias_pointer_stack  ; Address{_address:#h!!18}
[#h??00]                      ; {_concret:#h..00, Entity{_int:3, _num:4.0}}
[#h??00] _concret             ; #h..00
[#h??08]                      ; Entity{_int:3, _num:4.0}
[#h??08] _int                 ; 3
[#h??10] _num                 ; 4.0
[#h!!58] heap                 ; Pointer{_address:#h??00, _offset:8+0, _dynamic:#h..00}
[#h!!70] pointer_heap         ; Address{_address:#h!!58}
[#h!!78] pointer_pointer_heap ; Address{_address:#h!!70}
[#h!!80] alias_heap           ; Address{_address:#h!!58}
[#h!!88] alias_pointer_heap   ; Address{_address:#h!!70}
[#h??18]                      ; Shared{_refer:1, Pointer{_address:#h??00, _offset:8+0, _dynamic:#h..00}}
[#h??18] _refer               ; 1
[#h??20]                      ; Pointer{_address:#h??00, _offset:8+0, _dynamic:#h..00}
[#h!!90] reference_heap       ; Address{_shared:#h??18}

!! Do语言的值交换的示例
type Main
    func _Swap_Instance〈lside: Char, rside: Char〉
        auto temp ⊏ lside;     !! 函数调用的实例无交换
        lside ⊏ rside;
        rside ⊏ temp;

    func _Swap_Alias〈lside: &Char, rside: &Char〉
        auto temp ⊏ lside;     !! 函数调用的实例有交换
        lside ⊏ rside;
        rside ⊏ temp;

    func _Swap_Pointer〈lside: $Char, rside: $Char〉
        auto temp ⊏ lside;     !! 函数调用的实例无交换
        lside ⊏ rside;
        rside ⊏ temp;

    func _Swap_Pointer_Value〈lside: $Char, rside: $Char〉
        auto temp ⊏ lside.;    !! 函数调用的实例有交换
        lside. ⊏ rside.;
        rside. ⊏ temp;

    func _Swap_AliasPointer_Value〈lside: &$Char, rside: &$Char〉
        auto temp ⊏ lside;     !! 函数调用的一级指针有交换
        lside ⊏ rside;
        rside ⊏ temp;

    func _Swap_PointerPointer_Value〈lside: $$Char, rside: $$Char〉
        auto temp ⊏ lside.;    !! 函数调用的一级指针有交换
        auto lside. ⊏ rside.;
        rside. ⊏ temp;

### Do语言的类型转换与移位运算

Do语言的类型转换规则：类型转换失败会抛出异常。
其零，可读可写控制符是常量语义而不是常量类型。参考C++语言的const_cast<>()。
其一，根本数值类型根据内存长度自动作升格转换。
其二，根本数值类型之间可以相互作显式类型转换。参考C++语言的static_cast<>()。
其三，类体类型可以自定义类型转换操作符方法作显式类型转换。参考C++语言的operator Type()。
其四，派生类多级指针、别名、引用可以自动转换成基础类同级多级指针、别名、引用。
其五，基础类多级指针、别名、引用可以显式转换成派生类同级多级指针、别名、引用。参考C++语言的dynamic_cast<>()、dynamic_pointer_cast<>()。
其六，类体类型多级指针可以显式类型转换成地址型或者根本类型多级指针。参考C++语言的reinterpret_cast<>()。
其七，地址型或者根本类型多级指针可以显式类型转换成类体类型多级指针。参考C++语言的reinterpret_cast<>()。

定长整型异符同格转换对照表：
| 4位有符号补码 | 4位无符号整型 | 4位有符号原码 |
| ------------- | ------------- | ------------- |
| 0b0000，+0    | #b0000，0     | #b1000，+0    |
| 0b0001，+1    | #b0001，1     | #b1001，+1    |
| 0b0010，+2    | #b0010，2     | #b1010，+2    |
| 0b0011，+3    | #b0011，3     | #b1011，+3    |
| 0b0100，+4    | #b0100，4     | #b1100，+4    |
| 0b0101，+5    | #b0101，5     | #b1101，+5    |
| 0b0110，+6    | #b0110，6     | #b1110，+6    |
| 0b0111，+7    | #b0111，7     | #b1111，+7    |
| 0b1000，-8    | #b1000，8     | #b0000，-0    |
| 0b1001，-7    | #b1001，9     | #b0001，-1    |
| 0b1010，-6    | #b1010，10    | #b0010，-2    |
| 0b1011，-5    | #b1011，11    | #b0011，-3    |
| 0b1100，-4    | #b1100，12    | #b0100，-4    |
| 0b1101，-3    | #b1101，13    | #b0101，-5    |
| 0b1110，-2    | #b1110，14    | #b0110，-6    |
| 0b1111，-1    | #b1111，15    | #b0111，-7    |

补码芯片的整型异符同格升格降格转换（非通用标准）。
整型异符同格转换，内存无变化。整型异符同格转换满足幂等性。
整型异符升格转换，先做整型同符升格转换，再做整型异符同格转换。
整型异符降格转换，先做整型异符同格转换，再做整型同符降格转换。
signed   char positive         = (signed   char)+125;      // 0b01111101，+125
signed   char negative         = (signed   char)-125;      // 0b10000011，-125
unsigned char signless         = (unsigned char) 253;      // 0b11111101， 253
unsigned char isotope_positive = (unsigned char)positive;  // 0b01111101， 125，unsigned == ((+0 <= signed) ? signed : (signed + 2··8))
unsigned char isotope_negative = (unsigned char)negative;  // 0b10000011， 131，unsigned == ((+0 <= signed) ? signed : (signed + 2··8))
signed   char isotope_signless = (signed   char)signless;  // 0b11111101，  -3，signed   == ((unsigned < 2··7) ? unsigned : (unsigned - 2··8))

补码芯片的整型同符升格转换（非通用标准）。
整型同符升格转换，将整型按二进制增补，符号位若有则不变，低位保留，高位补符号位。整型同符升格转换的结果其数值相等。
signed   char  positive         = (signed   char )+125;       //         0b01111101，+125
signed   char  negative         = (signed   char )-125;       //         0b10000011，-125
unsigned char  signless         = (unsigned char ) 253;       //         0b11111101， 253
signed   short promote_positive = (signed   short)positive;   // 0b0000000001111101，+125
signed   short promote_negative = (signed   short)negative;   // 0b1111111110000011，-125
unsigned short promote_signless = (unsigned short)signless;   // 0b0000000011111101， 253

补码芯片的整型同符降格转换（非通用标准）。
整型同符降格转换，将整型按二进制截断，符号位若有则不变，高位丢弃，低位保留。整型同符降格转换的结果同整型余数运算。
signed   short positive          = (signed   short)+765;      // 0b0000001011111101，+765
signed   short negative          = (signed   short)-765;      // 0b1111110100000011，-765
unsigned short signless          = (unsigned short) 765;      // 0b0000001011111101， 765
signed   char  truncate_positive = (signed   char )positive;  //         0b01111101，+125，rema(positive, 2··7)
signed   char  truncate_negative = (signed   char )negative;  //         0b10000011，-125，rema(negative, 2··7)
unsigned char  truncate_signless = (unsigned char )signless;  //         0b11111101， 253，rema(signless, 2··8)

补码芯片的有符号整型与无符号整型比较大小（非通用标准）。
定长有符号整型与定长无符号整型不能直接比较大小。
两整型的最大位宽为n位，将两整型都升格转换为(n+1)位有符号整型，再比较大小。


原码芯片的整型异符同格升格降格转换（准通用标准）。
整型异符同格转换，最高位取反。整型异符同格转换满足幂等性。
整型异符升格转换，先做整型同符升格转换，再做整型异符同格转换。
整型异符降格转换，先做整型异符同格转换，再做整型同符降格转换。
auto positive         ⊏ (int1)+125;      !! b#10111111，+125
auto negative         ⊏ (int1)-125;      !! b#10111110，-125
auto signelss         ⊏ (uin1) 253;      !! b#10111111， 253
auto isotope_positive ⊏ (uin1)positive;  !! b#10111110， 125，unsigned = ((+0 <= signed) ? signed : (-signed + 2··7));
auto isotope_negative ⊏ (uin1)negative;  !! b#10111111， 253，unsigned = ((+0 <= signed) ? signed : (-signed + 2··7));
auto isotope_signless ⊏ (int1)signless;  !! b#10111110，-125，signed   = ((unsigned < 2··7) ? unsigned : -(unsigned - 2··7));

原码芯片的整型同符升格转换（准通用标准）。
整型同符升格转换，将整型按二进制增补，符号位若有则不变，低位保留，高位一律补0 。同符整型升格转换的结果其数值相等。
auto positive         ⊏ (int1)+125;      !! b#10111111        ，+125
auto negative         ⊏ (int1)-125;      !! b#10111110        ，-125
auto signelss         ⊏ (uin1) 253;      !! b#10111111        ， 253
auto promote_positive ⊏ (int2)positive;  !! b#1011111000000001，+125
auto promote_negative ⊏ (int2)negative;  !! b#1011111000000000，-125
auto promote_signless ⊏ (uin2)signless;  !! b#1011111100000000， 253

原码芯片的整型同符降格转换（准通用标准）。
整型同符降格转换，将整型按二进制截断，符号位若有则不变，高位丢弃，低位保留。同符整型降格转换的结果同整型余数运算。
auto positive          ⊏ (int2)+765;      !! b#1011111101000001，+765
auto negative          ⊏ (int2)-765;      !! b#1011111101000000，-765
auto signless          ⊏ (uin2) 765;      !! b#1011111101000000， 765
auto truncate_positive ⊏ (int1)positive;  !! b#10111111        ，+125，rema〈positive, 2··7〉
auto truncate_negative ⊏ (int1)negative;  !! b#10111110        ，-125，rema〈negative, 2··7〉
auto truncate_signless ⊏ (uin1)signless;  !! b#10111111        ， 253，rema〈signless, 2··8〉

原码芯片的有符号整型与无符号整型比较大小（准通用标准）。
定长有符号整型与定长无符号整型不能直接比较大小。
两整型的最大位数为n位，将两整型都升格转换为(n+1)位有符号整型，再比较大小。


补码芯片的整型移位运算（非通用标准）。补码芯片存在负整型右移不向零截断的问题。
定长整型左移<<运算，将整型按二进制指定位数向左移动，符号位若有则不变，移出位丢弃，右边空位一律补0 。整型左移运算的结果为整型乘以2··n，正整型左移越位后为0，负整型左移越位后为0。
定长整型右移>>运算，将整型按二进制指定位数向右移动，符号位若有则不变，移出位丢弃，左边空位补符号位。整型右移运算的结果为整型除以2··n向下取整，正整型右移越位后为0，负整型右移越位后为-1。
char negative = (char)-3;               // 0b11111101，-3
char shiftL1  = (char)(negative << 1);  // 0b11111010，-6
char shiftL2  = (char)(negative << 2);  // 0b11110100，-12
char shiftR1  = (char)(negative >> 1);  // 0b11111110，-2
char shiftR2  = (char)(negative >> 2);  // 0b11111111，-1
char shiftR3  = (char)(negative >> 3);  // 0b11111111，-1

原码芯片的整型移位运算（准通用标准）。原码芯片没有负整型右移不向零截型的问题。
定长整型右移>>运算，将整型按二进制指定位数向右移动，符号位若有则不变，移出位丢弃，左边空位一律补0。整型右移运算的结果为整型乘以2··n，正整型右移越位后为+0，负整型右移越位后为-0。
定长整型左移<<运算，将整型按二进制指定位数向左移动，符号位若有则不变，移出位丢弃，右边空位一律补0。整型左移运算的结果为整型除以2··n向零取整，正整型左移越位后为+0，负整型左移越位后为-0。
auto negative ⊏ (int1)-3;               !! b#11000000，-3
auto shiftR1  ⊏ (int1)(negative >> 1);  !! b#01100000，-6
auto shiftR2  ⊏ (int1)(negative >> 2);  !! b#00110000，-12
auto shiftL1  ⊏ (int1)(negative << 1);  !! b#10000000，-1
auto shiftL2  ⊏ (int1)(negative << 2);  !! b#00000000，-0
auto shiftL3  ⊏ (int1)(negative << 3);  !! b#00000000，-0

### Do语言的成员变量与读写控制符

相关关键字：auto、post、prop、para
相关关键词：成员变量、成员字段、成员信号、成员属性、读写控制符、可读控制符、可写控制符、常量语义

Do语言的变量或者方法的只可读性质是常量语义而不是常量类型。
Do语言中使用可读控制符⊏>定义的变量或者方法为只可读的，不能是赋值号以及复合赋值号的左侧直接变量，除此之外没有其它任何限制。
Do语言中使用可写控制符⊏ 定义的变量或者方法为可读写的，允许是赋值号以及复合赋值号的左侧直接变量，也允许出现在赋值号的右侧。

Do语言的成员变量只允许是异步类型，由于别名类型是同步类型，因此不允许别名类型是成员变量。
Do语言的根本类型的成员变量是使用auto关键字定义的成员字段，可以是公有的也可以是非公有的，可以是只可读的不带函数，也可以是可读写的不带函数。
Do语言的类体类型的成员变量是使用prop关键字定义的成员属性，可以是公有的也可以是非公有的，可以是只可读的不带setter函数，也可以是可读写带有setter函数，setter函数的输入实参通过para关键字获取。

type Main
    pack Enum
        auto _readonly ⊏> com8{1.0, 2.0};

    post _Enum   ⊏> !'Hello, World!';
    post _Memb   ⊏> _memb;
    post _Read   ⊏> uin8
        exit _memb;
    post _Signal ⊏> width: int8, factor: num8
        exit _signal;

    prop _memb ⊏ 0.0
        test((0.0 <= para) = nega)
            para ⊏ 0.0;
        test(_memb ¬= para)
            _memb ⊏ para;
            emit _Memb;
            emit _Read;

    prop _signal ⊏ width: 1, factor: 1.0
        auto flag ⊏ nega;
        test(_signal\width ¬= width)
            flag ⊏ posi;
            _signal\width ⊏ width;
        test(_signal\factor ¬= factor)
            flag ⊏ posi;
            _signal\factor ⊏ para\factor;
        test(flag = posi)
            emit _Signal;

    func _Readonly〈〉⊏> num8
        exit _memb;

    func _ReadWrite〈〉⊏ &num8
        exit _memb;

    func _Semantics〈〉
        auto readonly ⊏> 1.0;
        auto readwrite ⊏ 2.0;
        readonly  ⊏ 3.0;                        !! 编译期错误，只可读变量不能是赋值号以及复合赋值号的左侧直接变量
        readwrite ⊏ 4.0;
        (readwrite +⊏ readonly) ⊏ 5.0;          !! 编译期正确

        _Readonly〈〉⊏ 6.0;                     !! 编译期错误，只可读方法不能是赋值号以及复合赋值号的左侧直接变量
        _ReadWrite〈〉⊏ 7.0;
        (_ReadWrite〈〉+⊏ _Readonly〈〉) ⊏ 8.0;  !! 编译期正确

### Do语言的入口方法

相关关键字：main、self
相关的类型：Main、Self
相关关键词：入口方法、输入参数、输出参数、位置参数、关键参数、进程指针

Do语言的入口方法是Main特别类及其嵌套类中的main方法，Main特别类只允许定义在文件限定域中，main方法只允许定义在Main特别类及其嵌套类中。
Do语言的进程状态返回码在进程退出时由程序自动生成，在main方法的输出参数中无须定义。

Do语言的main方法不允许重载，main方法的输入参数与输出参数只允许是基本类型，可以有多个输入位置形参以及多个输入关键形参，可以有多个输出位置形参以及多个输出关键形参。位置形参在前，以冒号:分隔参数名与类型或者默认值，关键形参在后，以赋值号⊏分隔参数名与默认值。由于main方法的输入关键形参与输出关键形参未必赋值予实参，因此输入关键形参与输出关键形参都有默认值。

Do语言的进程类体是Self特别类，本进程指针通过self关键字获取。

type Main
    type Routine
        prop __help ⊏ nega;
        main Routine{help ⊏ nega} ⊏> code: bool
            Console._Print〈self._programpath〉;
            Console._Print〈self._programname〉;
            Console._Print〈self._workingfolder〉;

            __help ⊏ help;
            test(__help = posi)
                Console._Print〈!'Hello, World!'〉;
            exit code: posi;

    prop __protocol ⊏ !'';
    prop __help ⊏ nega;
    main Main{protocol: Char, help ⊏ nega} ⊏> code: bool, extra ⊏ !''
        Console._Print〈self._programpath〉;
        Console._Print〈self._programname〉;
        Console._Print〈self._workingfolder〉;

        __protocol ⊏ protocol;
        __help ⊏ help;
        test(__help = posi)
            _Help〈〉;
        test(__protocol ¬= !'protocol')
            Console._Print〈!'Unknown Protocol!'〉;
            exit code: nega, extra ⊏ !'failed';
        exit code: posi, extra ⊏ !'successful';

    ctor &Main{}
        Console._Print〈self._programpath〉;
        Console._Print〈self._programname〉;
        Console._Print〈self._workingfolder〉;

    func _Help〈〉
        Console._Print〈!'Hello, World!'〉;

    func _Calculate〈lhs: num8, rhs: num8〉⊏> result: num8
        exit result: lhs + rhs;

### Do语言的生命方法与特殊方法与全局单例

相关关键字：ctor、this
相关关键词：生命方法、构造方法、析构方法、特殊方法、全局单例、协程安全、初始化数组、本实例指针

Do语言的类体的生命方法包括构造方法与析构方法。
Do语言的构造方法最少有两个，都是公有的，带前导符&，构造方法在语法上没有返回值，可以互相调用本层的构造方法，也可以调用基层的构造方法。
Do语言的析构方法正好有一个，都是私有的，带前导符∽，析构方法在语法上没有返回值，实例析构时自动调用析构方法，也可以手动去调用析构方法。

Do语言有3个特殊方法：
00. 零输入形参的构造方法始终存在，未定义时由编译器生成。
01. 单输入形参为本类类型别名的构造方法始终存在，未定义时由编译器生成。
02. 零输入形参的析构方法始终存在，未定义时由编译器生成。

Do语言原生支持全局单例实例，全局单例实例通过零输入形参构造方法创建。Do语言的全局单例实例在使用时才即时创建，因此任何实例的创建都发生在main方法调用以后，Do语言保证全局单例实例的创建是协程安全的。

Do语言的类体实例是类体相关的，本实例指针通过this关键字获取。

type Main
    type Hash
        prop __hash ⊏ !'';
        @apply: Hash.prop
        ctor &Hash{that: &Hash}
            __hash ⊏ that\__hash;
        ctor &Hash{hash: &Char}
            __hash ⊏ hash;

    type Data: Hash
        type Count
            prop _count ⊏ 0;
            func _Increase〈〉
                _count +⊏ 1;
            func _Decrease〈〉
                _count -⊏ 1;

        prop __root ⊏ ($char)null;
        prop __capacity ⊏ 0;
        prop __size ⊏ 0;
        @apply: Data.prop
        ctor &Data(that: &Data}
            Count._Increase〈〉;
            $Hash{that};
            test((that\__size <= __capacity) = nega)
                auto capacity ⊏ that\__size;
                auto root ⊏ ($char)make char#capacity{};
                __root ⊏ root;
                __capacity ⊏ capacity;
            loop(auto ordi ⊏ 0; ordi < that\__size)
                (__root + ordi). ⊏ (that\__root + ordi).;
                ordi +⊏ 1;
            __size ⊏ that\__size;

        ctor &Data{init: &Init(char)}
            Count._count +⊏ 1;
            $Hash{!'&Init(char)'};
            test((init\_Size <= __capacity) = nega)
                auto capacity ⊏ init\_Size;
                auto root ⊏ ($char)make char#capacity{};
                __root = root;
                __capacity = capacity;
            loop(auto ordi ⊏ 0; ordi < init\_Size)
                (__root + ordi). ⊏ init[ordi];
                ordi +⊏ 1;
            __size ⊏ init\_Size;

        ctor ∽Data{}
            Count._Decrease〈〉;
            free __root, __root ⊏ null;
            __capacity ⊏ 0;
            __size ⊏ 0;

    main Main{}
        auto data ⊏ Data{!{          !! 仅调用构造方法
            'H', 'e', 'l', 'l', 'o'
        }};
        auto assign_copy ⊏ data;     !! 仅调用构造方法
        assign_copy ⊏ data;          !! 仅调用复制赋值操作符方法
        assign_copy ⊏ Data{!{        !! 先调用构造方法，再调用复制赋值操作符方法
            'H', 'e', 'l', 'l', 'o'
        }};

### Do语言的多重继承与类型推断

相关关键字：ctor、make、free、take
相关关键词：构造方法、析构方法、基底层、基础层、基父层、派生层、具体层、当前层、初始化、销毁化、类型推断

Do语言的继承机制采用类体的多重继承机制，为简化内存结构以及逻辑复杂性，Do语言不支持类体的菱形多重继承机制。

Do语言的类体的构造顺序：
步骤零，初始化基父层。按照类体的基父层的成员变量的定义顺序依次初始化。多继承时基父类的初始化顺序为其定义顺序。
步骤一，初始化派生层。按照类体的派生层的成员变量的定义顺序依次初始化。
步骤二，实构造派生层。调用类体的具体层的构造方法，重置类体的成员变量。
步骤三，实构造基父层。在类体的派生层的构造方法中调用基父层的构造方法。

Do语言的类体的析构顺序：
步骤零，实析构派生层。调用类体的具体层的析构方法，销毁置空类体的成员变量。
步骤一，实析构基父层。调用类体的基父层的析构方法，销毁置空类体的成员变量。多继承时基父类的实析构顺序为其定义顺序的逆序。
步骤二，销毁化派生层。按照类体的具体层的成员变量的定义顺序逆序依次销毁化。
步骤三，销毁化基父层。按照类体的基父层的成员变量的定义顺序逆序依次销毁化。多继承时基父类的销毁化顺序为其定义顺序的逆序。

type Main
    type Type00
        prop _memb00 ⊏ 00;
        ctor &Type00{}
            _memb00 ⊏ 00;
        ctor ~Type00{}
            ;
        func _Func00〈〉
            Console._Print〈_memb00〉;

    type Type10: Type00
        prop _memb10 ⊏ 10;
        ctor &Type10{}
            _memb10 ⊏ 10;
        ctor ~Type10{}
            ;
        func _Func10〈〉
            Console._Print〈_memb10〉;

    type Type11: Type11
        prop _memb11 ⊏ 11;
        ctor &Type11{}
            _memb11 ⊏ 11;
        ctor ~Type11{}
            ;
        func _Func11〈〉
            Console._Print〈_memb11〉;

    type Type20: Type10, Type11
        prop _memb20 ⊏ 20;
        ctor &Type20{}
            $Type10{};         !! 调用基父层的构造方法
            $Type00$Type11{};  !! 调用基础层的构造方法
        ctor ~Type20{}
            ;
        func _Func20〈〉
            Console._Print〈_memb20〉;

    type Type30: Type20
        prop _memb30 ⊏ 30;
        ctor &Type30{}
            _memb30 ⊏ 30;
        ctor ~Type30{}
            ;
        func _Func30〈〉
            Console._Print〈_memb30〉;

    func _Auto〈〉
        auto auto_type00_type11 ⊏ ($Type00)($Type11)make Type20{};
        auto auto_type00type11  ⊏ ($Type00$Type11  )make Type20{};
        free auto_type00_type11;  !! 销毁auto_type00_type11的实例，然后置空auto_type00_type11指针
        free auto_type00type11;   !! 销毁auto_type00type11 的实例，然后置空auto_type00type11 指针

    func _Flex〈〉
        flex flex_type00_type11 ⊏ ($Type00)($Type11)make Type20{};
        flex_type00_type11      ⊏ ($Type00$Type11  )make Type20{};
        free flex_type00_type11;  !! 销毁flex_type00_type11的实例，然后置空flex_type00_type11指针

    func _Type_Deduction〈〉
        auto type00_type11 ⊏ ($Type00)($Type11)make Type20{};
        auto type00_type10 ⊏ ($type00)($Type10)make Type20{};
        test(take $Type00$Type10$Type20: type00_type11)           !! 预判断右侧变量的动态类型是否可以转换为左侧推断的路径类型
            auto pointer ⊏ ($Type00$Type10$Type20)type00_type11;  !! Do语言的类型转换操作以当前层为基准
        test(take type00_type10        : type00_type11)           !! 左侧推断的路径类型是$Type00$Type10$Type20，右侧的动态类型是$Type00
            auto pointer ⊏ (take type00_type10   )type00_type11;  !! Do语言的类型转换操作以当前层为基准
        free type00_type11;
        free type11_type10;

!! Do语言的类体的内存布局结构的示例
class Type20 {
    void *_concret;
    struct Type20 {
        struct Type10 {
            struct Type00 {
                int _memb00;
            };
            int _memb10;
        };
        struct Type11 {
            struct Type00 {
                int _memb00;
            };
            int _memb11;
        };
        int _memb20;
    };
};

!! Do语言的方法运行栈的auto内存布局的示例
func _Auto〈〉
[#h..00] _trait_type00     ; {08, 0, [], ....}
[#h..10] _trait_type10     ; {16, 1, [#h..00], ....}
[#h..11] _trait_type11     ; {16, 1, [#h..00], ....}
[#h..20] _trait_type20     ; {40, 2, [#h..10, #h..11], ....}
[#h??00] _concret          ; #h..20
[#h??08]                   ; Type20{Type10{Type00{_memb00:00}, _memb10:10}, Type11{Type00{_memb00:00}, _memb11:11}, _memb20:20}
[#h??08]                   ; Type10{Type00{_memb00:00}, _memb10:10}
[#h??08]                   ; Type00{_memb00:00}
[#h??08] _memb00           ; 00
[#h??10] _memb10           ; 10
[#h??18]                   ; Type11{Type00{_memb00:00}, _memb11:11}
[#h??18]                   ; Type00{_memb00:00}
[#h??18] _memb00           ; 00
[#h??20] _memb11           ; 11
[#h??28] _memb20           ; 20
[#h!!00] auto_type00_type11; Auto{_address:#h??00, _offset:8+0, _dynamic:#h..00}  !! _offset加_dynamic可以唯一确定类体指针的当前层位置

!! Do语言的方法运行栈的flex内存布局的示例
func _Flex〈〉
[#h..00] _trait_type00     ; {08, 0, [], ....}
[#h..10] _trait_type10     ; {16, 1, [#h..00], ....}
[#h..11] _trait_type11     ; {16, 1, [#h..00], ....}
[#h..20] _trait_type20     ; {40, 2, [#h..10, #h..11], ....}
[#h??00] _concret          ; #h..20
[#h??08]                   ; Type20{Type10{Type00{_memb00:00}, _memb10:10}, Type11{Type00{_memb00:00}, _memb11:11}, _memb20:20}
[#h??08]                   ; Type10{Type00{_memb00:00}, _memb10:10}
[#h??08]                   ; Type00{_memb00:00}
[#h??08] _memb00           ; 00
[#h??10] _memb10           ; 10
[#h??18]                   ; Type11{Type00{_memb00:00}, _memb11:11}
[#h??18]                   ; Type00{_memb00:00}
[#h??18] _memb00           ; 00
[#h??20] _memb11           ; 11
[#h??28] _memb20           ; 20
[#h!!00] flex_type00_type11; Flex{_address:#h??00, _offset:8+0, _dynamic:#h..00}  !! _offset加_dynamic可以唯一确定类体指针的当前层位置

### Do语言的成员方法与占位值

相关关键字：func、hold
相关关键词：成员方法、占位值、函数式编程

Do语言的成员函数不可以重载只可读版本与可读写版本，可以有多个输入位置形参与多个输出位置形参，成员函数的指纹包括其读写控制符及其输出位置参数。
Do语言的输入位置形参的参数名是必须的，若用于输入实参处则是可选的，输入位置形参可以是类型或者默认值，而且与其实参的类型必须是类型兼容的。当输入位置实参使用默认值时，必须以hold关键字占位，Do语言不强制默认输入位置形参放在尾部。
Do语言的输出位置形参的参数名是可选的可改的，若用于输出实参处则是必须的，输出位置实参的类型是可选的，而且与其形参的类型必须是类型兼容的。当输出位置实参丢弃返回值时，必须以hold关键字占位，Do语言不强制默认输出位置形参放在尾部。
Do语言的成员函数当具有零个输出位置形参时，须要省略读写控制符，可以省略exit语句。


type Main
    prop __quot ⊏ 0;
    prop __rema ⊏ 0;

    main Main{}
        auto quot: &int8, rema: int8 ⊏ _Writable〈lhs: 1, rhs: 2〉;   !! 输出位置实参的类型是可选的而且与其形参的类型必须是类型兼容的
        quot ⊏ 3;                                                    !! 建议输出位置实参的参数名与其形参的参数名保持一致
        rema ⊏ 4;

        _Writable〈lhs: 5, rhs: 6〉\quot ⊏ 7;                         !! 输出位置形参的参数名若用于实参处则是必须的
        _Writable〈lhs: 5, rhs: 6〉\rema ⊏ 8;

        auto quot: int8, hold ⊏ _Writable〈lhs: hold, rhs: 9〉;       !! 当输入位置实参使用默认值或者输出位置实参丢弃返回值时，必须以hold关键字占位

        _Writable〈_Readable0〈lhs: hold〉, _Readable1〈rhs: 10〉〉;   !! 函数可串联其它函数的输出实参作为输入实参，以实现函数式编程

    func _Writable〈lhs: int8, rhs: int8〉⊏ quot: &int8, rema: &int8
        __quot ⊏ lhs // rhs;
        __rema ⊏ lhs %% rhs;
        exit __quot, __rema;

    func _Readable0〈lhs: 11  〉⊏> lhs: int8
        exit lhs;

    func _Readable1〈rhs: int8〉⊏> rhs: int8
        exit rhs;

### Do语言的操作符方法与打印格式

相关关键字：oper
相关关键词：操作符方法、字符表示操作符方法、打印格式

Do语言的操作符可划分为单目操作符、双目操作符、三目操作符，所有的操作符都只有一个返回值，所有的可重载的操作符方法都定义在类体限定域当中，操作符函数的访问规则与成员方法的访问规则相同。

Do语言的操作符的可重载规则：
其零，根本类型的操作符是内置预定义的，不能重写不能重载。
其一，不能创造全新的操作符，不能改变操作符的解析方式以及优先级，所有的操作符方法都只有一个返回值。
其二，不能改变操作符的目数，不能改变操作符的输入形参个数与位置，所有的操作符方法都是公有可继承的。
其三，操作符方法不能重载只可读版本与可读写版本。

!! Do语言的操作符方法的示例
type Main
    type Type
        prop __value     ⊏ num8{0.0};
        prop __magnitude ⊏ int8{0};
        oper -〈〉⊏ &Type                                      !! 重载单目操作符，本实例后置
            __value ⊏ -__value;
            exit (this.);
        oper ++〈〉⊏ &Type                                     !! 重载单目操作符，本实例后置
            ++__value;
            exit (this.);
        oper -〈that: &Type〉⊏> Type                           !! 重载双目操作符，本实例前置
            auto temp ⊏ (this.);
            temp\__value -⊏ that\__value;
            exit temp;
        oper ·〈that: num8〉⊏> Type                            !! 重载双目操作符，本实例前置
            auto temp ⊏ (this.);
            temp\__value ·⊏ that;
            exit temp;
        oper ::rule〈quantity: Char, magnitude: int8〉⊏ &Type  !! 重载三目操作符，本实例前置
            test(quantity = !'w')
                __value ·⊏ 10000;
                __magnitude +⊏ magnitude;
            exit (this.);
        oper !〈format: !''〉⊏> Char                           !! 重载单目操作符，本实例后置
            exit !'{__value}::rule^{__magnitude}';
        oper <<〈bites: uint8〉⊏> Type                         !! 重载双目操作符，本实例前置
            auto temp ⊏ this.;
            temp\__value <<⊏ bites;
            exit temp;
        oper >>〈bites: uint8〉⊏> Type                         !! 重载双目操作符，本实例前置
            auto temp ⊏ this.;
            temp\__value >>⊏ bites;
            exit temp;
        oper <<<〈stream: &Stream〉⊏ &Stream                   !! 重载双目操作符，本实例后置
            stream << __value << __magnitude;
            exit stream;
        oper >>>〈stream: &Stream〉⊏ &Stream                   !! 重载双目操作符，本实例后置
            stream >> __value >> __magnitude;
            exit stream;


Do语言的字符表示操作符方法用于返回该实例的字符数组表示，基本类型的字符表示操作符方法是内置预定义的，其它类型重写其字符表示操作符方法即可实现自定义打印格式。

Do语言的科学记数法格式：
  ±0.fraction·base··exponent  !! 基数为十进制
  ±0.fraction##exponent       !! 基数为十进制，底数为十进制
#b±0.fraction##exponent       !! 基数为二进制，底数为二进制
#d±0.fraction##exponent       !! 基数为十进制，底数为十进制
#h±0.fraction##exponent       !! 基数为十六进制，底数为十六进制

Do语言的基本类型的内置格式：
b，按位二进制打印
d，按位十进制打印
h，按位十六进制打印
f，按位三十二进制打印
s，按位六十四进制打印
c，按位EAGB颜色打印
B，按格二进制打印
D，按格十进制打印
H，按格十六进制打印
F，按格三十二进制打印
S，按格六十四进制打印
C，按格EAGB颜色打印
##，按科学记数法打印

Do语言规范规定，对于基本类型指定的打印格式必须完全匹配基本类型的正则打印格式，特定类型提取正则打印格式的相关字段进行打印，否则返回空字节数组。
[<=>][!!][##specifier][`'"][$+][length][.specific]
[<=>]        ，可选项。分别是左对齐、中对齐、右对齐，未指定时是中对齐。填充字符是空格符。
[!!]         ，可选项。!打印前缀，!!打印!号与前缀。
[##specifier]，可选项。#表示方向顺序，specifier是内置格式。#specifier表示从右往左，specifier#表示从左往右。##表示按科学记数法打印。
[`'"]        ，可选项。`按紧凑UCS编码打印，'"按码表UCS编码打印，而且打印引号，必要时打印长度，前缀的编码跟随引号内编码。未指定时按码表UCS编码打印。
[$+]         ，可选项。$按内存打印。无论是有符号整型，还是有符号浮点型，都按无符号整型打印，而且打印$号。+打印+号。
[length]     ，可选项。正半轴整数，是整体长度，未指定时是自适应长度，对于数值型是填充、前缀、引号、正负号、小数点前、小数点、小数点后、指数符、虚数符的长度之和，对于位域型是位域的位数，对于布尔型是4个字符。超出此长度会发生截断。
[.specific]  ，可选项。正半轴整数，是小数点后长度。未指定时是其精确度减去小数点前长度。

!! Do语言的打印格式的示例
type Main
    sole Sole                               !! (dyna  Sole )\_bites = 64 ，(dyna  Sole )\_bytes = 8 ，(dyna  Sole )\_cells = 1
        auto _num8 ⊏ num8{1.0};
        auto _int8 ⊏ int8{1};               !! 默认初始化的最后一个字段才有效

    pack Pack                               !! (dyna  Pack )\_bites = 128，(dyna  Pack )\_bytes = 16，(dyna  Pack )\_cells = 1
        auto _num8 ⊏ num8{1.0};
        auto _int8 ⊏ int8{1};

    pack Type
        auto _iptr  ⊏ iptr  {$#h8000000000000000, $#h8000000000000008};  !! iptr是有符号整型
        auto _bite4 ⊏ bite:4{1};            !! (dyna _bite4)\_bites = 4  ，(dyna _bite4)\_bytes = 1 ，(dyna _bite4)\_cells = 1
        auto _byte  ⊏ byte  {#h0A};         !! (dyna _byte )\_bites = 8  ，(dyna _byte )\_bytes = 1 ，(dyna _byte )\_cells = 1
        auto _char  ⊏ char  {#h000A};       !! (dyna _char )\_bites = 16 ，(dyna _char )\_bytes = 2 ，(dyna _char )\_cells = 1
        auto _char4 ⊏ char#4{               !! (dyna _char4)\_bites = 64 ，(dyna _char4)\_bytes = 8 ，(dyna _char4)\_cells = 4
            'A', 'B', 'C', 'D'              !! 等价于'ABCD'
        };
        auto _uin8  ⊏ uin8  {10};           !! (dyna _uin8 )\_bites = 64 ，(dyna _uin8 )\_bytes = 8 ，(dyna _uin8 )\_cells = 1
        auto _int8  ⊏ int8  {10};           !! (dyna _int8 )\_bites = 64 ，(dyna _int8 )\_bytes = 8 ，(dyna _int8 )\_cells = 1
        auto _int84 ⊏ int8#4{               !! (dyna _int84)\_bites = 256，(dyna _int84)\_bytes = 32，(dyna _int84)\_cells = 4
            h#A0, h#B0, h#C0, h#D0
        };
        auto _num8  ⊏ num8  {10.0};         !! (dyna _num8 )\_bites = 64 ，(dyna _num8 )\_bytes = 8 ，(dyna _num8 )\_cells = 1
        auto _num84 ⊏ num8#4{               !! (dyna _num84)\_bites = 256，(dyna _num84)\_bytes = 32，(dyna _num84)\_cells = 4
            1.0, 2.0, 3.0, 4.0
        };
        auto _com8  ⊏ com8  {10.0, -20.0};  !! (dyna _com8 )\_bites = 64 ，(dyna _com8 )\_bytes = 8 ，(dyna _com8 )\_cells = 1

    type Entity
        type Enum
            prop _sequential ⊏> 'b#';
            prop _numeral    ⊏> '#b';

        prop _value ⊏ uin8{0};

        oper !〈format: !''〉⊏> Char
            test(format = Enum._sequential)
                auto repr ⊏ !'';
                loop(auto shift ⊏ 0; auto size ⊏ (dyna _value)\_bytes; shift < size)
                    repr +⊏ (char)((_value << shift) ∧∧ b#10);
                    shift +⊏ 1;
                exit repr;
            test(format = Enum._numeral)
                auto repr ⊏ !'';
                loop(auto shift ⊏ 0; auto size ⊏ (dyna _value)\_bytes; shift < size)
                    repr +⊏ (char)((_value << shift) ∧∧ b#10);
                    shift +⊏ 1;
                repr\_Reverse〈〉;
                exit repr;
            exit !'';

    func _Predefined〈〉
        Console._Print〈![!#h$]Type._iptr 〉  ;   !! 返回!`$#h8000000000000000+8000000000000008`  !! 有符号数按十六进制内存打印
        Console._Print〈Type._bite4〉         ;   !! 返回!`1000`
        Console._Print〈(int8)Type._bite4〉   ;   !! 返回!`1`
        Console._Print〈![!b#]Type._bite4〉   ;   !! 返回!`b#1000`
        Console._Print〈Type._byte〉          ;   !! 返回!`A`
        Console._Print〈(int8)Type._byte〉    ;   !! 返回!`10`
        Console._Print〈![!#h`]Type._byte 〉  ;   !! 返回!6`#h`0A``
        Console._Print〈Type._char 〉         ;   !! 返回!`A`
        Console._Print〈(int8)Type._char 〉   ;   !! 返回!`10`
        Console._Print〈![!#h']Type._char 〉  ;   !! 返回!`#h'000A'`
        Console._Print〈![!#h']Type._char4〉  ;   !! 返回!`#h'000D000C000B000A'`
        Console._Print〈![!#d]Type._uin8 〉   ;   !! 返回!`#d10`
        Console._Print〈![!#d+]Type._int8〉   ;   !! 返回!`#d+10`
        Console._Print〈![!#d+]Type._int84〉  ;   !! 返回!`#d+13+12+11+10`
        Console._Print〈![!d#+]Type._int84〉  ;   !! 返回!`d#01+11+21+31+`
        Console._Print〈![!#D+]Type._int84〉  ;   !! 返回!`#D31+21+11+01+`
        Console._Print〈![!D#+]Type._int84〉  ;   !! 返回!`D#+10+11+12+13`
        Console._Print〈![!#d+.4]Type._num8〉 ;   !! 返回!`#d+10.0000`            !! 打印浮点型时应该指定小数点后长度
        Console._Print〈![!#d+.4]Type._num84〉;   !! 返回!`#d+4.0+3.0+2.0+1.0`
        Console._Print〈![!#d+.4]Type._com8〉 ;   !! 返回!`#d+10.0000-20.0000τ`

        auto packing ⊏ Pack{};
        auto soleing ⊏ Sole{};
        Console._Print〈![<!#d+6.1]packing〉;     !! 返回!`#d+1  #d+1.0`  !! 等价于![<!#d+6.1](packing\_int8) + ![<!#d+6.1](packing\_num8)
        Console._Print〈![<!#d+6.1]soleing〉;     !! 返回!`#d+1  #d????`  !! 等价于![<!#d+6.1](packing\_int8) + ![<!#d+6.1](packing\_num8)

    func _Customized〈〉
        auto entity ⊏ Entity{};
        Console._Print〈![#b]entity〉;                  !! !'#b'作为输入实参传入object\oper !〈〉
        Console._Print〈entity\oper !〈!'#b'〉〉;

        auto date   ⊏ Date{!'2025/12/12'};
        Console._Print〈![YYYY/MM/DD]date〉;            !! !'YYYY/MM/DD'作为输入实参传入date\oper !〈〉
        Console._Print〈date\oper !〈!'YYYY/MM/DD'〉〉;

### Do语言的匿名函数与函数变量

相关关键字：type、ctor、func、oper、take
相关关键词：面向过程编程、面向实体编程、函数变量、实体函数、匿名类体、匿名函数、函数式编程

Do语言是面向实体编程的计算机语言，Do语言中的函数总是与其实例指针绑定在一起的，因此Do语言中的函数变量总是存储有其实例指针。

Do语言支持匿名类体以及匿名函数用于函数式编程，Do语言的匿名类体可以自定义成员变量以及成员函数，Do语言的匿名函数可以捕获额外的变量，包括this指针变量以及引用类型变量。

type Type
    prop _member ⊏ !'Hello';

    take func〈&Char〉= Visit;
    func _Func〈visit: &Visit, para: &Char〉
        visit〈para〉;

    !! Do语言的函数变量的示例
    func _Function_Variable〈〉
        func ____Visit〈para: &Char〉  !! 本实体函数的全量指纹是Type.func ____Visit〈&Char〉
            _member ⊏ !'World';       !! 原值有影响
            para    ⊏ !'World';       !! 原值有影响

        _Func〈____Visit, !'Hello'〉;  !! !'Hello'实例存储在_Func方法的运行栈内存中

    !! Do语言的匿名类体的示例
    func _Anonymous_Type〈〉
        auto extra  ⊏ !'Hello';
        auto rextra ⊏ &extra;
        auto pextra ⊏ $extra;
        _Func〈type {this, extra, rextra, pextra}  !! 本匿名类体的全量指纹是type {$Type, Char, $Char, $Char}
            prop _this   ⊏ ($Type)null;
            prop _extra  ⊏ !'';
            prop _rextra ⊏ ($Char)null;            !! 类体的成员变量不能是引用类型
            prop _pextra ⊏ ($Char)null;
            ctor &{parent: $Type, extra: Char, rextra: &Char, pextra: $Char}
                _this   ⊏ parent;
                _extra  ⊏ extra;
                _rextra ⊏ $rextra;                 !! 获取原值的地址
                _pextra ⊏ pextra;
            oper〈〉〈para: &Char〉                 !! 本函数调用操作符方法的全量指纹是type {$Type, Char, $Char, $Char}.oper〈〉〈&Char〉
                _this._member ⊏ !'World';          !! 原值有影响
                _extra        ⊏ !'World';          !! 原值无影响
                _rextra.      ⊏ !'World';          !! 原值有影响
                _pextra.      ⊏ !'World';          !! 原值有影响
                para          ⊏ !'World';          !! 原值有影响
        , !'Hello'〉;

    !! Do语言的匿名函数的示例
    func _Anonymous_Function〈〉
        auto extra  ⊏ !'Hello';
        auto rextra ⊏ &extra;
        auto pextra ⊏ $extra;
        !! 捕获this指针变量与引用类型变量是Do语言的内置机制
        _Func〈{this, extra, rextra, pextra}〈para: &Char〉 !! 本匿名函数的全量指纹是type {$Type, Char, &Char, $Char}.oper〈〉〈&Char〉
            _member ⊏ !'World';                            !! 原值有影响
            extra   ⊏ !'World';                            !! 原值无影响
            rextra  ⊏ !'World';                            !! 原值有影响
            pextra. ⊏ !'World';                            !! 原值有影响
            para    ⊏ !'World';                            !! 原值有影响
        , !'Hello'〉;

### Do语言的指纹与限定域

相关关键字：comp、dyna
相关的类型：Dyna
相关关键词：编译型语言、解释型语言、即时编译执行、编译期信息、运行期信息、指纹、签名、全量指纹、足量签名、类别限定字、标识名、标签名、读写控制符、动态类型、具体类型、限定域

Do语言是编译型语言兼解释型语言，Do语言编译器用于编译可执行的机器指令，Do语言解释器用于运行时动态地解释执行，编译器按源代码文件、类体类型、语句块的层次架构编译成机器指令，解释器通过调用编译器即时将语句块编译成机器指令，然后即时执行。

Do语言的特点是动态类型编译定义，Do语言的类型信息可划分为编译期信息与运行期信息，编译期信息通过comp关键字直接获取，编译期信息是与限定域上下文相关的。运行期信息借助dyna关键字创建Dyna类型实例，然后通过成员信号间接获取。Do语言的类型信息是类型固有的编译器内部表示，可以查询但是无法修改。

Do语言的类型信息首要是全量指纹然后是足量签名。标识名包括后导下划线不包括前导下划线，标签名包括后导下划线也包括前导下划线。指纹即无歧义访问的信息，指纹是签名的精简版。签名即完整而有效的信息，签名是指纹的完整版。类型信息的足量版本不带路径前缀，类型信息的全量版本带有路径前缀。
Do语言在同一个限定域内的标识名是唯一确定的，因此在同一个限定域内的标签名是唯一确定的。
Do语言的外层类与其内层类是相互独立无关联的。

Do语言的指纹：
其零，变量的指纹包括其类别限定字、标签名、读写控制符、动态类型。
其一，函数的指纹包括其类别限定字、标签名、泛型模板形参以至实参、输入位置形参动态类型、读写控制符、输出位置形参动态类型。
其二，类型的指纹包括其类别限定字、标签名、泛型模板形参以至实参、直属成员变量动态类型。

Do语言的签名：
其零，变量的签名包括其类别限定字、标签名、读写控制符、动态类型、具体类型。
其一，函数的签名包括其类别限定字、标签名、泛型模板形参以至实参、输入位置形参标签名以及动态类型、输入关键形参标签名以及动态类型、读写控制符、输出位置形参标签名以及动态类型、输出关键形参标签名以及动态类型。
其二，类型的指纹包括其类别限定字、标签名、泛型模板形参以至实参、基父类标签名以及泛型模板形参以至实参、直属成员变量标签名以及动态类型。

Do语言的限定域：
其零，方法限定域对外封闭，成员包括共用体、组合体、类体、方法、变量。方法限定域中的成员定义有先后顺序。
其一，类体限定域对外开放，成员包括共用体、组合体、类体、变量、方法。类体限定域中的变量定义有先后顺序，其它成员定义无先后顺序。
其二，文件限定域对外开放，成员包括共用体、组合体、类体。文件限定域中的成员定义无先后顺序。
其三，私房限定域对外封闭，若文件以双叹号!!开头，则压缩成归档库或者编译成运行库以后，该文件对外封闭。

!! Do语言的所有的类型的示例
type Main
    sole Sole
        auto _one ⊏ int8{0};
        auto _two ⊏ num8{0.0};
        auto _tri ⊏ com8{0.0, 0.0};

    pack Pack
        auto _bite ⊏ bite:4{0};
        auto _int8 ⊏ int8{0};
        auto _num8 ⊏ num8{0.0};
        auto _com8 ⊏ com8{0.0, 0.0};
        auto _char ⊏ char#5{
            'A', 'B', 'C', 'D'
        };

    type Type00
        prop _memb00 ⊏ 00;
        func _Func〈〉
            ;
    type Type10: Type00
        prop _memb10 ⊏ 10;
        func _Func〈〉
            ;
    type Type11: Type00
        prop _memb11 ⊏ 11;
        func _Func〈〉
            ;
    type Type20: Type10, Type11
        prop _memb20 ⊏ 20;
        func _Func〈〉
            ;
    type Type30: Type20
        prop _memb30 ⊏ 30;
        func _Func〈〉
            ;

    post _Signal ⊏> _signal;
    prop _signal ⊏ width: 1, factor: 1.0
        _signal\width  ⊏ width;
        _signal\factor ⊏ factor;
        emit _Signal;

    main Main{protocol: Char, help ⊏ nega} ⊏> code: int8, info ⊏ !''
        Console._Print〈self._programpath〉;
        Console._Print〈self._programname〉;
        exit +0, !'no errors.';

    ctor &Main{width: int8, factor: num8}
        _signal ⊏ width, factor;
    ctor ~Main{}
        ;

    take func〈&Char〉⊏> int8 = Printer;
    func _Print〈printer: &Printer, sequence: &Char〉⊏> code: int8
        auto code ⊏ printer._Print〈sequence〉;
        exit code;

    func _Func(Type_: int8 | uin8 | com8, const:> int8)〈width: int8, factor: num8〉
        type Type(Type_)
            prop _type ⊏ Type_{};
            oper〈〉〈&Char〉⊏> int8
                exit +0;
        type Type(Type_ = com8)
            prop _type ⊏ Type_{};
            oper〈〉〈&Char〉⊏> int8
                exit +0;
        func ____Local〈&Char〉⊏> int8
            exit +0;

        auto anonymous ⊏ type {this, width, factor}〈&Char〉⊏> int8
            prop _this   ⊏ ($Main)null;
            prop _width  ⊏ 0;
            prop _factor ⊏ 0.0;
            ctor &{parent: $Main, width: int8, factor: num8}
                _this   ⊏ parent;
                _width  ⊏ width;
                _factor ⊏ factor;
            oper〈〉〈&Char〉⊏> int8
                exit +0;
        auto lambda    ⊏ {this, width, factor}〈&Char〉⊏> int8
            exit +0;

        _Print〈Type., !this.〉;

    func _Info〈〉
        Console._Print〈comp._class_function_fingerprint_complete〉;
        Console._Print〈comp._class_function_signature_adequate〉;

        auto dynamic ⊏ ($Type00$Type11)make Type20{};
        Console._Print〈(dyna dynamic)\_bites〉;
        Console._Print〈(dyna dynamic)\_bytes〉;
        Console._Print〈(dyna dynamic)\_cells〉;
        Console._Print〈(dyna dynamic)\_fingerprint_adequate〉;
        Console._Print〈(dyna dynamic)\_signature_adequate〉;
        Console._Print〈(dyna dynamic)\_dynamic_type〉;
        Console._Print〈(dyna dynamic)\_concret_type〉;

    oper !〈format: !''〉⊏> Char
        auto repr !'';
        repr += !##'{'##;
        repr += !'{_signal\width}, {_signal\factor}';
        repr += !##'}'##;
        exit repr;

!! Do语言的指纹的示例
type Main
    type Base
        type Enum
            prop _type0 ⊏> Base{};  !! Do语言的外层类与其嵌套类是相互独立无关联的
            prop _type1 ⊏> Base{};

        @initiate
        prop _public     ⊏ int8{0};
        @initiate
        prop __protected ⊏ int8{0};
        @initiate
        prop ___private  ⊏ int8{0};

        @initiate
        post _Public     ⊏> _public;
        @initiate
        post __Protected ⊏> __protected;
        @initiate
        post ___Private  ⊏> ___private;

    type Derived: Base
        @initiate
        prop _public     ⊏ num8{0.0};
        @initiate
        prop __protected ⊏ num8{0.0};
        @initiate
        prop ___private  ⊏ num8{0.0};

        @initiate
        post _Public     ⊏> _public;
        @initiate
        post __Protected ⊏> __protected;
        @initiate
        post ___Private  ⊏> ___private;

    main Main{}
        auto pbase ⊏ ($Base)make Derived{};
        Console._Print〈pbase:_public〉;        !! 等价于访问(($Base)pbase)._public
        Console._Print〈pbase:_public(int8)〉;  !! 等价于访问(($Base)pbase)._public
        Console._Print〈pbase:_public(num8)〉;  !! 等价于访问(($Derived)pbase)._public
        emit pbase:_Public;                    !! 等价于发射(($Base)pbase)._Public
        emit pbase:_Public(int8);              !! 等价于发射(($Base)pbase)._Public
        emit pbase:_Public(num8);              !! 等价于发射(($Derived)pbase)._Public


### Do语言的条件语句与循环语句

相关关键字：test、else、loop、keep、quit
相关关键词：条件语句、循环语句、序数标、迭代器

Do语言的条件语句由多项组成，末项是必选项判断条件，其它项是可选项，通常是变量定义。Do语言的条件语句中定义的变量是局部变量。

Do语言的循环语句类似于条件语句，若判断条件为真则执行当前子语句块，若判断条件为假则执行else子语句块。

Do语言的循环语句支持序数标语法，也支持迭代器语法，不支持集合项语法。Do语言的迭代器类似于引用类型有两层结构。

type Main
    type Enum
        take Char = Locale;
        prop _zh_cn ⊏> Locale{'中文•中国大陆'};
        prop _en_us ⊏> Locale{'english•The United States'};

    !! Do语言的条件语句的示例
    func _Switch〈〉
        auto locale ⊏ Enum._zh_cn;
        test(locale = Enum._zh_cn)
            Console._Print〈Enum._zh_cn〉;
        else(locale = Enum._en_us)
            Console._Print〈Enum._en_us〉;
        else
            Console._Print〈!'????'〉;

    !! Do语言的循环语句的示例
    func _Loop_Short〈〉
        loop(auto ordi ⊏ 0; ordi < 10)
            test(ordi < 5)
                ordi +⊏ 1;
                keep;
            else(ordi = 7)
                Console._Print〈!'found and quit from loop.'〉;
                quit;
            Console._Print〈!'ordi = {ordi}'〉;
            ordi +⊏ 1;
        else
            Console._Print〈!'unfound due to false condition.'〉;

    !! Do语言的序数标语法的示例
    func _Loop_Ordinal〈〉
        auto vectorR ⊏ [0:3:1.0];
        auto vectorI ⊏ [0:2:1.0];
        auto surface ⊏ Array(num8, 2){vectorR._Size, vectorI._Size};
        loop(auto [ordiR, ordiI] : vectorR, vectorI)    !! 序数标语法须要实例具有下标操作符函数
            surface[ordiR, ordiI] ⊏ vectorR[ordiR] ·· 2 + vectorI[ordiI] ·· 2;
        Console._Mesh〈vectorR, vectorI, surface〉;

        !! Do语言的序数标语法的等价过程
        !! loop(auto ordiR ⊏ 0; ordiR < vectorR._Size)
        !!     loop(auto ordiI ⊏ 0; ordiI < vectorI._Size)
        !!         surface[ordiR, ordiI] ⊏ vectorR[ordiR] ·· 2 + vectorI[ordiI] ·· 2;
        !!         ordiI +⊏ 1;
        !!     ordiR +⊏ 1;

    !! Do语言的迭代器语法的示例
    func _Loop_Iterator〈〉
        auto vectorR ⊏ [0:3:1〉;
        auto vectorI ⊏ [0:2:1〉;
        auto summation ⊏ int8{0};
        loop(auto〈iter〉: vectorR, vectorI)              !! 迭代器语法须要实例具有迭代器成员信号
            summation +⊏ iter.;

        !! Do语言的迭代器语法的等价过程
        !! loop(auto iter ⊏ vectorR._Begin; iter < vectorR._Endup)
        !!     summation +⊏ iter.;
        !!     ++iter;
        !! loop(auto iter ⊏ vectorI._Begin; iter < vectorI._Endup)
        !!     summation +⊏ iter.;
        !!     ++iter;

    !! Do语言的迭代器遍历的示例
    func _Iterator_Erase〈〉
        auto vector ⊏ Vector(num8){!{
            1.0, 2.0, 3.0, 4.0, 5.0
        }};
        loop(auto iter ⊏ vector._Begin; iter ¬= vector._Endup)
            test(iter. = 2.0)
                iter\_Erase〈〉;  !! Do语言的迭代器采用C++语言的迭代器与Java语言的迭代器的综合形式。
            else
                ++iter;


### Do语言的异常语句与异常体系

相关关键字：deem、cast、what、last、post、prop、main、func、oper
相关的特性：@throw
相关关键词：异常队列、调用栈回溯、异常体系

Do语言的异常允许发生在任何代码处，包括类体的构造函数与类体的析构函数。若任何代码在抛出异常以后，运行栈在回溯的过程中再次抛出异常，比如在数组析构的全过程中，则所有的异常按发生的顺序依次进入异常队列。Do语言的异常实例以及异常队列，都位于分配堆内存上。

Do语言在deem语句块中使用cast语句抛出异常，然后循环依次在what语句块中处理异常队列，无论有无异常发生都会在last语句块中结束异常处理。cast语句只能抛出继承自标准异常的类类型。

Do语言的异常语句还可以位于协程上下文，用于整个协程的异常监测。Do语言的异常语句还可以位于main函数上，用于整个进程的异常监测。main函数的异常语句优先于Main类体成员变量的初始化。

Do语言中浮点数相关的异常运算，大多数都被CPU处理掉了而不会抛出。

Do语言的标准异常体系：
Anomaly
|- Fault      !! 内存错误相关的异常
|- Error      !! 运行错误相关的异常
|- Exception  !! 外部错误相关的异常
|- Mistake    !! 逻辑错误相关的异常，此类异常大多数都被CPU处理掉了而不会抛出

type Main
    prop __help ⊏ nega;
    main Main{help: bool}
        __help ⊏ help;
        Console._Print〈!'help = {__help}'〉;
    what(anomaly: &&$Anomaly)
        Console._Print〈!anomaly:〉;  !! 调用anomaly:oper !〈〉
    last
        Console._Print〈!'quitting...'〉;

    !! Do语言的异常机制的示例
    @throw: Char
    func _Exception〈〉
        !! 采用异常机制读写文件
        auto file ⊏ make File{!'notes#note'};
        deem
            test(file._Open〈File.enum._read_only〉= nega)
                cast Exception{!'file open failed!'};  !! cast关键字类似于make关键字，在分配堆内存上创建异常的实例的引用
            Console._Print〈!'file open successful!'〉;
        what(except: &&$Exception)
            Console._Print〈!except:〉;
        what(anomaly: &&$Anomaly)
            Console._Print〈!anomaly:〉;
            cast anomaly;                              !! 重新抛出异常
        last
            file._Close〈〉;                            !! 文件关闭操作为可选项
            free file;

    func _Closable〈〉
        !! 采用引用机制读写文件
        auto closable ⊏ &&make File{!'notes#note'};
        test(file._Open〈File.enum._read_only〉= nega)
            Console._Print〈!'file open failed!'〉;
            exit;
        Console._Print〈!'file open successful!'〉;
        !! closable引用在超出限定域时会自动执行free操作

### Do语言的比较运算与逻辑演绎

相关关键词：全路运算、短路运算、命题逻辑、命题联词、谓词逻辑、谓词量词、逻辑演绎

| 缩略 | 命题联词（共6个） | 语法  | 真值 | 真值 | 真值 | 真值 |
| :--: | :---------------: | :---: | :--: | :--: | :--: | :--: |
|      |                   |   P   |  0   |  0   |  1   |  1   |
|      |                   |   Q   |  0   |  1   |  0   |  1   |
| lnot |      逻辑非       |  ¬P   |  1   |  1   |  0   |  0   |
| land |      逻辑与       | P ∧ Q |  0   |  0   |  0   |  1   |
| lore |      逻辑或       | P ∨ Q |  0   |  1   |  1   |  1   |
| lexc |      逻辑异       | P ⊔ Q |  0   |  1   |  1   |  0   |
| limp |     逻辑蕴涵      | P → Q |  1   |  1   |  0   |  1   |
| lequ |     逻辑等价      | P ↔ Q |  1   |  0   |  0   |  1   |

| 缩略 |  谓词量词（共3个）   |        语法        | 等价逻辑                                    |
| :--: | :------------------: | :----------------: | ------------------------------------------- |
| eall | 全称量词，存在所有的 | `∀x∈setX{_P〈x〉}` | `_P〈x₀〉∧ _P〈x₁〉∧ ...`                   |
| eany | 存在量词，存在任意的 | `∃x∈setX{_P〈x〉}` | `_P〈x₀〉∨ _P〈x₁〉∨ ...`                   |
| eone | 特称量词，存在唯一的 | `Ⅎx∈setX{_P〈x〉}` | `∃x∈setX{_P〈x〉∧ ∀y∈setX{_P〈y〉→ (x=y)}}` |


Do语言的相等号是=，恒等号是==，非相等号是¬=，非恒等号是¬==。
Do语言的复合操作符全部不可重载，Do语言的复合操作由内置机制实现。

Do语言的相等语义是变量的内存值规约相等，Do语言的恒等语义是变量的内存值精确相等。
Do语言的赋值号是⊏，表示变量的内存值为其字面值的规约值，因此变量的内存值与其字面值规约相等，但未必精确相等。
Do语言的int8{-0} = int8{+0}，但是int8{-0} ¬== int8{+0}，因为有符号整型的最高位是符号位，-0与+0的最高位不相等。
Do语言的num4{0.1##-50} = num4{0.1##-60}，而且num4{0.1##-50} == num4{0.1##-60}，因为根本数值类型都是定长的。

Do语言的命题联词以及谓词量词都是全路运算的，条件运算都是短路运算的。Do语言的命题联词∧∨⊔的优先级是同级的。
因为命题运算是硬件层机制，物理电气电路是完整的而不是支离的，然而条件运算是软件层机制，软件中断跳址可以实现短路运算操作。
Do语言的操作符的解析方式以及优先级是固定的，因此命题联词运算符可以重载，条件运算符不可重载。
Do语言支持连续的比较运算，通过转换为等价的条件运算来实现。

type Main
    !! Do语言的比较运算的示例
    type Type
        prop __value ⊏ 0.0;

        oper <=>〈that: &Type〉⊏> int8
            auto diff = __value - that\__value;
            test(diff < 0.0)
                exit -1;
            else(diff > 0.0)
                exit +1;
            else          !! 须要考虑浮点数不精确相等
                exit +0;

        oper <〈that: &Type〉⊏> bool
            exit (this.oper <=>〈that〉< 0);
        oper >〈that: &Type〉⊏> bool
            exit (this.oper <=>〈that〉> 0);
        oper =〈that: &Type〉⊏> bool
            exit (this.oper <=>〈that〉= 0);

        oper ==〈that: &Type〉⊏> bool
            auto root ⊏ ($byte)$__value;
            auto head ⊏ ($byte)$(that\__value);
            loop(auto ordi ⊏ 0; auto size ⊏ (dyna __value)\_Bytes; ordi < size)
                test((root + ordi). ¬= (head + ordi).)
                    quit;
            else
                exit posi;
            exit nega;

    !! Do语言的连续的比较运算的示例
    func _Consecutive〈〉
        auto minimum ⊏ 0;
        auto maximum ⊏ 100;
        auto variable0 ⊏ 50;
        auto variable1 ⊏ 60;
        test(minimum <= variable0 < variable1 < maximum)
            Console._Print〈!'fine'〉;
        test((minimum <= variable0) ? (variable0 < variable1) ? (variable1 < maximum))
            Console._Print〈!'fine'〉;

    !! Do语言的命题联词的示例
    func _Proposition〈prop0: bool, prop1: bool, prop2: bool, prop3: bool〉
        auto land_lore_land ⊏ (prop0 ∧ prop1) ∨ (prop2 ∧ prop3);
        auto lore_land_lore ⊏  prop1 ∧ (prop1 ∨ prop2) ∧ prop3;

    !! Do语言的谓词量词的示例
    func _Predicate〈〉
        type Pred0
            oper〈〉〈x: num8〉⊏> bool
                exit posi;
        type Pred1
            oper〈〉〈y: num8〉⊏> bool
                exit nega;
        func ____Pred0〈x: num8〉⊏> bool
            exit posi;
        func ____Pred1〈y: num8〉⊏> bool
            exit nega;
        auto pred0 ⊏ {this}〈x: num8〉⊏> bool
            exit posi;
        auto pred1 ⊏ {this}〈y: num8〉⊏> bool
            exit nega;

        auto setX ⊏ Vector(double){!{
            1.0, 2.0, 3.0
        }};
        auto setY ⊏ Vector(double){!{
            4.0, 5.0, 6.0
        }};
        auto pred_type      ⊏ ∀x::setX{∀y::setY{Pred0.〈x〉∧ Pred1.〈y〉}};
        auto pred_function  ⊏ ∀x::setX{∀y::setY{____Pred0〈x〉∧ ____Pred1〈y〉}};
        auto pred_anonymous ⊏ ∀x::setX{∀y::setY{pred0〈x〉∧ pred1〈y〉}};

    !! Do语言的谓词逻辑的等价过程
    take func〈num8〉      ⊏> bool = Pred1;
    take func〈num8, num8〉⊏> bool = Pred2;
    func _Predicate_Expression〈pred1: &Pred1, pred2: &Pred2, setX: &Vector(double), setY: &Vector(double)〉
        auto logic_eall ⊏ ∀x::setX{pred1〈x〉};
        func ____Logic_eall〈pred1: &Pred1, setX: &Vector(double)〉⊏> bool
            auto eall ⊏ posi;
            loop(auto〈iterX〉: setX)
                eall ⊏ eall ∧ pred1〈iterX.〉;
            exit eall;

        auto logic_eany ⊏ ∃x::setX{pred1〈x〉};
        func ____Logic_eany〈pred1: &Pred1, setX: &Vector(double)〉⊏> bool
            auto eany ⊏ nega;
            loop(auto〈iterX〉: setX)
                eany ⊏ eany ∨ pred1〈iterX.〉;
            exit eany;

        auto logic_eall_eall ⊏ ∀x::setX{∀y::setY{pred2〈x, y〉}};
        func ____Logic_eall_eall〈pred2: &Pred2, setX: &Vector(double), setY: &Vector(double)〉⊏> bool
            auto eallX ⊏ posi;
            loop(auto〈iterX〉: setX)
                auto eallY ⊏ posi;
                loop(auto〈iterY〉: setY)
                    eallY ⊏ eallY ∧ pred2〈iterX., iterY.〉;
                eallX ⊏ eallX ∧ eallY;
            exit eallX;

        auto logic_eall_eany ⊏ ∀x::setX{∃y::setY{pred2〈x, y〉}};
        func ____Logic_eall_eany〈pred2: &Pred2, setX: &Vector(double), setY: &Vector(double)〉⊏> bool
            auto eallX ⊏ posi;
            loop(auto〈iterX〉: setX)
                auto eanyY ⊏ nega;
                loop(auto〈iterY〉: setY)
                    eanyY ⊏ eanyY ∨ pred2〈iterX., iterY.〉;
                eallX ⊏ eallX ∧ eanyY;
            exit eallX;

    !! Do语言的条件运算的示例
    func _Condition〈one: num8, two: num8, tri: num8〉
        auto less ⊏ (one < two) ? one ?? two;  !! 二选一逻辑，只要one以及two的类型兼容，可以不是bool类型
        (less < tri) | (less ⊏ tri);           !! 判假逻辑，less可以不是bool类型
        !! (less < tri) | (less ⊏ tri; nega);  !! 等价过程

        auto more ⊏ (one < two) | one || two;  !! 二选一逻辑，只要one以及two的类型兼容，可以不是bool类型
        (more < tri) ? (more ⊏ tri);           !! 判真逻辑，more可以不是bool类型
        !! (more < tri) ? (more ⊏ tri; posi);  !! 等价过程

    !! Do语言的条件运算的等价过程
    func _Condition_Expression〈cond0: bool, cond1: bool, cond2: bool, cond3: bool〉
        auto logic_cand_core ⊏ cond0 ? cond1 | cond2;
        func ____Logic_cand_core〈cond0: bool, cond1: bool, cond2: bool〉⊏> bool
            test(cond0)
                test(cond1)
                    exit posi;
                else
                    exit cond2;
            else
                exit nega;

        auto logic_core_cand ⊏ cond0 | cond1 ? cond2;
        func ____Logic_core_cand〈cond0: bool, cond1: bool, cond2: bool〉⊏> bool
            test(cond0)
                exit posi;
            else
                test(cond1)
                    exit cond2;
                else
                    exit nega;

        auto logic_candcand_core ⊏ cond0 ? cond1 ?? cond2 | cond3;
        func ____Logic_candcand_core〈cond0: bool, cond1: bool, cond2: bool〉⊏> bool
            auto temp ⊏ bool{};
            test(cond0)
                temp ⊏ cond1;  !! 判真逻辑
            else
                temp ⊏ cond2;
            test(temp)
                exit posi;
            else
                exit cond3;

        auto logic_corecore_cand ⊏ cond0 | cond1 || cond2 ? cond3;
        func ____Logic_corecore_cand〈cond0: bool, cond1: bool, cond2: bool〉⊏> bool
            auto temp ⊏ bool{};
            test(cond0)
                temp ⊏ cond2;  !! 判假逻辑
            else
                temp ⊏ cond1;
            test(temp)
                exit cond3;
            else
                exit nega;

### Do语言的特性与单位制

相关的特性：@deprecate、@flag、@suppress、@abstract、@initiate、@override、@throw、@apply
相关的类型：Unit
相关关键词：角进制、角度、弧度、单位制、自然历单位制

Do语言的@deprecate特性，用于标记过时弃用，修饰类体、变量、函数。
Do语言的@flag特性     ，用于编译期宏条件，修饰类体、变量、函数、语句。
Do语言的@suppress特性 ，用于抑制编译警告，修饰类体、变量、函数、语句。
Do语言的@abstract特性 ，用于声明抽象定义，修饰类体、成员函数、操作符函数。
Do语言的@initiate特性 ，用于声明首次定义，修饰成员字段、成员信号、成员属性、成员函数、操作符函数。
Do语言的@override特性 ，用于声明再次定义，修饰成员字段、成员信号、成员属性、成员函数、操作符函数。
Do语言的@throw特性    ，用于表明潜在异常，修饰成员信号、成员属性、成员函数、局部函数、操作符函数。
Do语言的@apply特性    ，用于应用成员功能，修饰类体、成员函数、局部函数、操作符函数。
Do语言的@abstract特性与@initiate特性与@override特性是互斥的。当类体有成员标记为@abstract特性时，该类体也须要标记为@abstract特性，抽象类不可实例化。

type Main
    @abstract
    type Abstract
        @initiate
        prop _memb ⊏ 0.0;

        @abstract
        func _Func〈info: &Char, extra: &Char〉;

    type Base
        @override
        prop _memb ⊏ 1.0;

        @initiate
        @apply: Char.prop
        func _Func〈info: &Char, extra: &Char〉
            @flag: debug
            Console._Print〈comp._class_function_name〉;

            @suppress: Alert_unused_variable
            extra;
            Console._Print〈info〉;
            Console._Print〈info\__size〉;

    type Type: Base
        @override
        prop _memb ⊏ 2.0;

        @deprecate: Version_11_0_0
        @override
        @throw: Mistake
        func _Func〈info: &Char, extra: &Char〉
            @flag: debug
            Console._Print〈comp._class_function_name〉;

            Console._Print〈info〉;
            Console._Print〈extra〉;
            test(info = !'')
                cast Mistake{!'info is empty.'};

    main Main{}
        auto abstract ⊏ ($Abstract)make Type{};
        abstract._Func〈info: !'', extra: !''〉;  !! 编译器错误，抽象方法未实现

Do语言的进位制在表层采用十进制，在底层采用二进制。Do语言的角进制在表层采用角度制，在底层采用弧度制。
Do语言的内置单位制采用自然历单位制为标准单位制，也支持自定义单位制，通过重载oper ::〈〉操作符函数以及应用@apply特性来实现。

type Main
    type Custom
        pack Pack
            auto _value  ⊏ num8{0.0};
            auto _second ⊏ int4{0};
            auto _ruler  ⊏ int4{0};
            auto _cheng  ⊏ int4{0};
            !! 其它单位

        type Constant
            prop _g ⊏> 6.67·10··(-11) · (1/0.238)··3 · (1000/13.5)··(-1) ::seco^-2::rule^3::chen^-1;  !! G ≈ 6.674×10⁻¹¹ s⁻²·m³·kg⁻¹;

        type Enum
            prop _void ⊏> !'';
            prop _w    ⊏> !'w';
            prop _g    ⊏> !'g';
            prop _c    ⊏> !'c';

        prop __pack ⊏ Pack{};

        ctor &Custom{value: num8}
            __pack\_value  ⊏ value;
            __pack\_second ⊏ 0;
            __pack\_ruler  ⊏ 0;
            __pack\_cheng  ⊏ 0;

        func ___Quantity〈quantity: &Char, magnitude: int4〉;
            test(quantity = Enum._w)
                __pack\_value ·⊏ Math._Power〈10000, magnitude〉;
            else(quantity = Enum._g | quantity = Enum._void)
                __pack\_value ·⊏ Math._Power〈1, magnitude〉;
            else(quantity = Enum._c)
                __pack\_value /⊏ Math._Power〈10000, magnitude〉;
            else
                cast Mistake{!'unknown quantity'};

        oper ::second〈quantity: Char, magnitude: int4〉⊏> &Unit
            ___Quantity〈quantity, magnitude〉;
            __pack\_second +⊏ magnitude;
            exit (this.);
        oper ::ruler〈quantity: Char, magnitude: int4〉⊏> &Unit
            ___Quantity〈quantity, magnitude〉;
            __pack\_ruler  +⊏ magnitude;
            exit (this.);
        oper ::cheng〈quantity: Char, magnitude: int4〉⊏> &Unit
            ___Quantity〈quantity, magnitude〉;
            __pack\_cheng  +⊏ magnitude;
            exit (this.);

        oper !〈format: !''〉⊏> Char
            exit !'{__pack\_value}::seco^{__pack\_second}::rule^{__pack\_ruler}::chen^{__pack\_cheng}';

    !! Do语言的角进制的示例
    func _Angle〈〉
        auto degree_into_radian ⊏ θ/180;  !! 角度360 = 弧度2θ
        auto radian_into_degree ⊏ 180/θ;  !! 角度1 = 弧度θ/180
        auto degree ⊏ °360 + °1;          !! Do语言表层采用角度制用于数值计算更为精确
        auto radian ⊏ °360·degree_into_radian + °1·degree_into_radian;

    !! Do语言的内置单位制的示例
    func _Gravitational_Force〈〉
        auto mass_1   ⊏ 1::chen;
        auto mass_2   ⊏ 1::chen;
        auto distance ⊏ 1::rule;
        auto force    ⊏ Unit.Constant._g · (mass_1 · mass_2) / (distance··2);

    !! Do语言的自定义单位制的示例
    @apply: Custom.ctor, Custom.oper
    func _Custom_System〈〉
        auto ruler_1      ⊏ 1 ::ruler;
        auto ruler_10000  ⊏ 1::wruler;
        auto acceleration ⊏ (9.8/0.238)::second^-2::ruler  !! 调用Custom{9.8/0.238}\oper ::second〈!'', -2〉\oper ::ruler〈!'', 1〉;

### Do语言的协程与进程

相关关键字：asyn、task、what、last、fork
相关的特性：@standalone
相关的类型：Task、Self
相关关键词：协程、进程、前台协程、后台协程、前台进程、中台进程、后台进程

Do语言没有线程但有协程，协程是更轻量级的线程。

C++语言Qt框架的线程机制：
00. 信号发射方式有1种：emit关键字在类体内部或者类体外部都可以发射。
01. 信号接收方式有3种：同线程直连调用、异线程异步队列、异线程同步调用。信号首次连接时无法读取信号的初值。
02. 信号连接方式有3种：全局作用域单个连接、全局作用域多个连接、全局作用域单次连接。信号声明函数与信号连接函数是多对多的关系。
03. 信号断开方式有4种：按信号发送者断开、按信号声明函数断开、按信号接收者断开、按信号连接函数断开。若信号连接采用匿名函数则难以断开连接。
04. 信号销毁方式有2种：当信号发送者销毁时、当信号接收者销毁时。
05. 事件循环机制有1种：每个线程都有独立的事件队列以及事件循环。实例在创建以后手动移入目标线程，父实例及其子实例必须处于同一个线程当中。
06. 生命周期机制有2种：按C/C++语言原生销毁实例、按Qt框架线程事件销毁实例。
07. 运行周期机制有1种：销毁线程时与该线程关联的实例不会自动销毁，销毁线程后与该线程关联的实例无法按Qt框架事件处理与销毁，当与该线程关联的实例全部销毁后该线程的运行周期不会自动结束，线程无法设置自动销毁模式。因此线程的运行周期以及生命周期必须大于实例的生命周期。

Do语言的协程机制：
00. 信号发射方式有2种：调用成员信号getter函数间接发射，绕过成员信号getter函数直接发射。emit关键字在类体内部或者类体外部都可以发射。
01. 信号接收方式有1种：接收者协程异步队列。信号首次连接时可选读取一次信号的初值。
02. 信号连接方式有1种：类体实例函数限定域唯一连接。信号声明函数与信号连接函数是一对多的关系。
03. 信号断开方式有4种：按信号发送者断开、按信号声明函数断开、按类体实例断开、按上下文信号连接函数断开。
04. 信号销毁方式有1种：当类体实例销毁时。
05. 事件循环机制有1种：每个协程都有独立的事件队列以及事件循环。实例在其上下文协程中创建并绑定，父实例及其子实例无须处于同一个协程当中。
06. 生命周期机制有1种：按协程事件销毁实例。
07. 运行周期机制有1种：销毁协程时与该协程关联的实例将会自动销毁，销毁协程后与该协程关联的实例不复存在而自动停止事件处理，当与该协程关联的实例全部销毁后该协程的运行周期将会自动结束，协程可以设置自动销毁模式。因此协程的运行周期以及生命周期可以等于实例的生命周期。

Do语言的协程可划分为前台协程、后台协程，前台协程须要手动销毁协程，后台协程可以自动销毁协程。前台后台协程在协程启动时设置。主协程是后台协程。
Do语言的进程可划分为前台进程、中台进程、后台进程，前台进程须要手动销毁进程，中台进程在主协程结束以后不会自动销毁进程，后台进程在主协程结束以后将会自动销毁进程。前台中台后台进程在进程启动时设置。

Do语言不支持协程组与进程组，也不支持守护协程与守护进程。Do语言的协程与进程的优先级都采用有符号整型。

Do语言的本协程指针通过task关键字获取，本进程指针通过self关键字获取。

!! Do语言的协程的示例
type Main
    func _Func〈local: &Char〉
        @throw: Mistake
        func ____Calculate〈number: uin8〉⊏> isit: bool, number: uin8
            Console._Print〈task._taskid〉;
            Console._Print〈task._taskname〉;
            task._Sleep〈Time{0, 0, 0, cseco:10}〉;

            auto sqrt ⊏ (uin8)Math._Square_Root〈number〉;
            loop(auto step ⊏ 2; step <= sqrt)
                test(step = 0)
                    cast Mistake{!'divide by zero.'};
                test(number % step = 0)
                    quit;
            else
                exit posi, number;
            exit nega, number;
        what(mistake: &&$Mistake)
            Console._Print〈!mistake:〉;
        what(anomaly: &&$Anomaly)
            Console._Print〈!anomaly:〉;
        last
            !! Console._Print〈local〉;  !! 编译期错误，函数异常语句块不允许访问上下文变量
            Console._Print〈!'done.'〉;


        !! type Asyn(bool, uin8): Task;
        !! Task类型没有_Start〈〉函数与_Sync〈〉函数，Asyn类型才有_Start〈〉函数与_Sync〈〉函数
        auto cotask ⊏ asyn{taskname ⊏ !'cotask'} ____Calculate〈109〉;  !! cotask的类型是$Asyn(bool, uin8)
        cotask._Start〈Task.Enum._foreground〉;
        !! do something concurrently.
        auto isit, number   ⊏ cotask._Sync〈〉;                         !! 同步协程，若协程未启动则启动协程
        auto isit2, number2 ⊏ cotask._Sync〈〉;                         !! 可以多次同步协程
        free cotask;                                                    !! 析构协程，若协程未结束则结束协程
        test(isit = posi)
            Console._Print〈!'{number} is     a prime.'〉;
        else
            Console._Print〈!'{number} is not a prime.'〉;

### Do语言的信号机制与事件机制

相关关键字：post、emit、pick、undo、vine
相关关键词：协程通信、驱动策略、信号机制、回调机制、事件机制、事件队列、事件循环

Do语言的协程通信采用信号机制，不采用函数回调机制，信号的发送与信号的接收通常位于不同的协程中。
Do语言的驱动策略采用事件机制，通过异步响应事件与队列处理事件来及时地驱动程序执行以及界面更新。

C++语言Qt框架的信号机制：
00. 使用signals关键字声明信号，类体成员信号不带getter函数，因此在任何时刻都不可读取信号的当前值。类体成员信号可以重载可以继承。
01. 使用emit关键字发射信号，可以在类体内部或者类体外部发射信号。
02. 使用QObject::connect()函数连接信号，在全局作用域中都可以连接信号。信号连接函数可以重载可以继承。
03. 使用QObject::disconnect()函数断开信号，在全局作用域中都可以断开信号。若信号连接采用匿名函数则难以断开连接。
04. 使用事件缓冲队列处理信号，若信号发送者线程与信号接收者线程不是相同的，信号事件就会进入信号接收者线程的事件缓冲队列。异线程阻塞等待信号结束可能导致死锁。
05. 任意类型捕获实参以及形参，由于线程机制可自定义线程类体，以及异步信号机制建立在实例复制的基础之上，因此允许任意类型捕获实参以及输入形参。

Do语言的信号机制：
00. 使用post关键字声明信号，类体成员信号带有getter函数，因此在任何时刻都可以读取信号的当前值。类体成员信号不可重载可以继承。
01. 使用emit关键字发射信号，可以在类体内部或者类体外部发射信号，可以调用成员信号getter函数间接发射，可以绕过成员信号getter函数直接发射。
02. 使用pick关键字连接信号，信号连接函数类似于类体局部方法定义，其隐含this指针是其上下文实例。信号连接函数不可重载不可继承，信号首次连接时可选读取一次信号的初值。
03. 使用undo关键字断开信号，只能在类体内部断开信号，可以按函数指纹断开所有相同的信号连接函数，可以按上下文信号连接函数断开。
04. 使用事件缓冲队列处理信号，无论信号发送者协程与信号接收者协程是否相同，信号事件都会进入信号接收者协程的事件缓冲队列。信号发射以后不再返回，不会导致死锁。
05. 异步类型捕获实参以及形参，由于信号机制建立在协程机制的基础之上，因此信号连接函数的捕获参数以及输入形参只允许是异步类型，不能是别名类型。

Do语言的事件机制其实就是信号机制：
00. 信号机制的产生源是特定的，事件机制的产生源非特定的。
01. 信号连接函数是不可重载不可继承的局部成员方法，事件处理函数是不可重载可以继承的类体成员方法。

Do语言使用vine关键字定义事件拦截函数与事件分发函数与事件处理函数，事件拦截函数与事件分发函数与事件处理函数在语法上都没有返回值。
Do语言的事件在产生以后，首先传递到具体的实例，如果该实例处理未竟，那么事件继续传递到下一个实例，下一个实例可能是父级的实例，也可能是同级的实例，还可能是别级的实例。


!! Do语言的信号机制的示例
type Main
    type Sender
        post _Signal ⊏> _signal;
        prop _signal ⊏ bulk: !'', rbulk: &&make !'';
            bool flag ⊏ nega;
            test(_signal\bulk ¬= para\bulk)
                flag ⊏ posi;
                _signal\bulk ⊏ para\bulk;
            test(_signal\rbulk. ¬= para\rbulk.)
                flag ⊏ posi;
                _signal\rbulk. ⊏ para\rbulk.;
            test(flag = posi)
                emit _Signal;

        func _Send〈〉
            func ____Emit〈bulk: &Char, rbulk: &&$Char〉
                task._Sleep〈Time{0, 0, 0, cseco:10}〉;
                _signal ⊏ bulk, rbulk;
            auto bulk  ⊏ !'Hello, World!';
            auto rbulk ⊏ &&make !'Hello, World!';
            auto cotask ⊏ asyn ____Emit〈bulk, rbulk〉;  !! asyn关键字在编译期通过检测函数指纹是否满足异步类型
            cotask._Start〈Task.Enum._background〉;

    type Receiver
        prop _text   ⊏ !'Hello';
        prop _sender ⊏ make Sender{};
        ctor ~Receiver{}
            undo _sender._Signal;    !! 断开与本实例关联的所有的指纹是_sender._Signal的信号连接函数
            undo _sender;            !! 断开与本实例关联的所有的指纹是_sender的信号连接函数
            free _sender;            !! 销毁_sender会自动断开与本实例关联的所有的信号发送者是_sender的信号连接函数
            !! 析构本实例会自动断开与本实例关联的所有的信号连接函数

        func _Receive〈〉
            auto extra  ⊏ !'Hello';
            auto pextra ⊏ make !'Hello';
            !! 同一函数限定域中不允许重复定义相同指纹的信号连接函数
            !! 信号连接函数相当于匿名函数，其指纹也包括捕获参数
            pick{extra, pextra} _sender._Signal〈bulk: Char, rbulk: &&$Char〉  !! 若extra或者pextra析构也不会自动断开信号连接函数
                _text   ⊏ !'World';  !! 原值有影响
                extra   ⊏ !'World';  !! 原值无影响
                pextra. ⊏ !'World';  !! 原值有影响
                bulk    ⊏ !'World';  !! 原值无影响
                rbulk.  ⊏ !'World';  !! 原值有影响
                undo pick;           !! 断开当前上下文的信号连接函数，相当于上下文信号连接函数做单次连接
                free pextra;
            pick{extra}         _sender._Signal(bulk: Char, rbulk: &&$Char)   !! 当信号连接函数使用圆括号()时，信号首次连接时不会读取一次信号的初值。
                undo pick;
                Console._Print〈_text〉;
                Console._Print〈extra〉;
                Console._Print〈bulk〉;
                Console._Print〈rulk.〉;
            _sender._Send〈〉;

    main Main{}
        auto receiver ⊏ Receiver{};
        receiver\Receive〈〉;

!! Do语言的事件机制的示例
type Main: Widget
    type Background: Widget
        ctor &Background{parent: $Widget}
            $Widget{parent};
        !! 事件分发函数
        vine _Event_Dispatcher〈event: $Event〉
            test(event._type = Event.Enum._mouse_press)
                Console._Print〈comp._function_name〉;
                event._accepted ⊏ nega;          !! 事件处理未竟允许继续传递
            $Widget._Event_Dispatcher〈event〉;   !! 调用基础层的事件分发函数
        !! 事件处理函数
        vine _Event_Mouse_Press〈event: $MouseEvent〉
            Console._Print〈comp._function_name〉;
            event._accepted ⊏ posi;              !! 事件处理完毕不再继承传递

    type Item0: Widget
        ctor &Item0{parent: $Widget}
            $Widget{parent};
        !! 事件分发函数
        vine _Event_Dispatcher〈event: $Event〉
            test(event._type = Event.Enum._mouse_press)
                Console._Print〈comp._function_name〉;
                event._accepted ⊏ nega;          !! 事件处理未竟允许继续传递
            $Widget._Event_Dispatcher〈event〉;   !! 调用基础层的事件分发函数
        !! 事件处理函数
        vine _Event_Mouse_Press〈event: $MouseEvent〉
            Console._Print〈comp._function_name〉;
            event._accepted ⊏ posi;              !! 事件处理完毕不再继承传递

    type Item1: Widget
        ctor &Item1{parent: $Widget}
            $Widget{parent};
        !! 事件分发函数
        vine _Event_Dispatcher〈event: $Event〉
            test(event._type = Event.Enum._mouse_press)
                Console._Print〈comp._function_name〉;
                event._accepted ⊏ nega;          !! 事件处理未竟允许继续传递
            $Widget._Event_Dispatcher〈event〉;   !! 调用基础层的事件分发函数
        !! 事件处理函数
        vine _Event_Mouse_Press〈event: $MouseEvent〉
            Console._Print〈comp._function_name〉;
            event._accepted ⊏ posi;              !! 事件处理完毕不再继承传递

    main Main{}
        prop _background ⊏ make Background{this};
        prop _item0      ⊏ make Item0{_background};
        prop _item1      ⊏ make Item1{_background};
        main Main{}
            _background._event_interceptor ⊏ this;
            _item0     ._event_interceptor ⊏ this;
            _item1     ._event_interceptor ⊏ this;
            this._Show〈〉;
        vine _Event_Interceptor〈watched: $Widget, event: $Event〉
            test(watched = _background)
                test(event._type = Event.Enum._mouse_press)
                    event._accepted ⊏ posi;  !! 事件处理完毕不再继承传递
            event._accepted ⊏ nega;          !! 事件处理未竟允许继续传递
        vine _Event_Close〈event: $CloseEvent〉
            Console._Print〈comp._function_name〉;
            event._closed   ⊏ nega;          !! 阻止窗体被关闭
            event._accepted ⊏ posi;          !! 事件处理完毕不再继承传递

### Do语言的读写锁机制与协程调度机制

相关关键字：lock、sync、task
相关关键词：读锁、写锁、读写锁、可重入锁、协程调度

| 读写锁 | 读操作 | 写操作 |
| :----: | :----: | :----: |
| 读状态 |  共享  |  互斥  |
| 写状态 |  互斥  |  互斥  |

![Do语言的协程调度机制.drawio](images/Do语言的协程调度机制.drawio.svg)

Do语言原生支持读写锁机制，lock关键字用于定义读锁语句块，sync关键字用于定义写锁语句块。
读写锁的读锁，以读取的方式锁定资源，若其它协程以读取的方式获取锁，则其它协程共享资源，若其它协程以写入的方式获取锁，则其它协程阻塞等待。
读写锁的写锁，以写入的方式锁定资源，若其它协程以读写的方式获取锁，则其它协程阻塞等待，若其它协程以写入的方式获取锁，则其它协程阻塞等待。

Do语言的读写锁是可重入的。Do语言的协程队列是实例相关的，协程队列中协程的顺序，在考虑协程优先级以及读写操作的情况下，严格按照协程到达读写锁的顺序。

Do语言的读写锁机制以及协程调度机制的实现方案：
步骤零，none状态的协程，进入lock更改其状态为read，进入sync更改其状态为write，然后挂起附加到pending队列的尾部。
步骤一，若doing队列为空，则将suspending队列附加到pending队列的头部，然后从pending队列的头部取出连续多个read状态的协程，亦或者一个write状态的协程移入doing队列，然后并发执行doing队列中所有的协程。
步骤二，read状态的协程或者write状态的协程，执行完毕进入none状态更改其状态为none，然后从doing队列中移除。
步骤三，read状态的协程，进入sync更改其状态为write，write状态的协程，进入lock更改其状态为read，然后挂起从doing队列中取出附加到suspending队列的尾部。
步骤四，read状态的协程或者write状态的协程，进入turn挂起然后从doing队列中取出附加到pending队列的尾部。
步骤五，read状态的协程或者write状态的协程，进入wait挂起然后从doing队列中取出附加到suspending队列的尾部。
步骤六，当出现wake操作，则将hanging队列附加到pending队列的尾部。

type Main
    type ReadWriteDict(Key_, Value_)
        prop __dict ⊏ Dict(Key_, Value_){};
        func _Get〈key: &Key_〉⊏> value: Value_
            lock{timeout ⊏ Time{0, 0, 0, cseco:10}}  !! 尝试在10尘秒内获取与this指针关联的读锁
                loop((0 < __dict\_Size) = nega)
                    task._Wait〈〉;                   !! 解除当前上下文的读锁然后挂起协程
                    !! 重新获取当前上下文的读锁
                exit __dict\_Get〈key〉;
        func _Put〈key: &Key_, value: &Value_〉
            sync
                __dict\_Put〈key, value〉;
                task._Wake〈〉;                       !! 唤醒所有与this指针关联的被挂起的协程
        func _Clean〈〉
            sync{timeout ⊏ Time{0, 0, 0, cseco:10}}   !! 尝试在10尘秒内获取与this指针关联的写锁
                loop((0 < __dict\_Size) = nega)
                    task._Wait〈〉;                   !! 解除当前上下文的写锁然后挂起协程
                    !! 重新获取当前上下文的写锁
                __dict\_Clear〈〉;

    !! Do语言的读写锁的状态转移的示例
    func _ReentrantReadWriteLock_StateTransition〈〉
        prop _count ⊏ 0;
        Console._Print〈!'[enter none] _count = {_count}'〉;
        lock
            Console._Print〈!'[enter lock] _count = {_count}'〉;
            sync
                Console._Print〈!'[enter sync] _count = {_count}'〉;
                _count +⊏ 1;
                lock
                    Console._Print〈!'[enter lock] _count = {_count}'〉;
                Console._Print〈!'[enter sync] _count = {_count}'〉;
            Console._Print〈!'[enter lock] _count = {_count}'〉;
        Console._Print〈!'[enter none] _count = {_count}'〉;

### Do语言的字节流与序列化

相关关键字：oper
相关的类型：Stream
相关关键词：字节流、序列化、反序列化、序列化操作符方法、反序列化操作符方法

Do语言在Stream类型中提供所有的基本类型的序列化方法与反序列化方法的实现。
Do语言将类体实例序列化成字节流可以通过重载序列化操作符方法并调用Stream类型来实现。
Do语言将字节流反序列化成类体实例可以通过重载反序列化操作符方法并调用Stream类型来实现。

!! Do语言的序列化的示例
type Main
    !! Do语言Stream类型的部分实现
    type Stream
        post _Buffer    ⊏> Byte{__buffer, __fore, __back};
        prop __buffer   ⊏ ($byte)null;
        prop __capacity ⊏ 0;
        prop __fore     ⊏ 0;
        prop __back     ⊏ 0;

        func _Serialize(Type_)〈struct: &Type_#cells〉⊏ &Stream
            func ____Assure_Back〈size: int8〉
                test((__back + size <= __capacity) = nega)
                    auto capacity ⊏ __back + size · 2;
                    auto buffer   ⊏ ($byte)make byte##capacity{};
                    loop(auto ordi ⊏ 0; ordi < __back)
                        (buffer + ordi). ⊏ (__buffer + ordi).;
                        ordi +⊏ 1;
                    free __buffer;
                    __buffer   ⊏ buffer;
                    __capacity ⊏ capacity;

            auto bytes ⊏ (dyna Type_)\_Bytes · cells;
            ____Assure_Back〈size〉;
            loop(auto iter ⊏ ($byte)$struct; auto ordi ⊏ 0; ordi < bytes)
                (__buffer + __back). +⊏ (iter + ordi).;
                __back +⊏ 1;
                ordi +⊏ 1;
            exit (this.);

        func _Serialize(Type_)〈struct: $Type_, uin8: cells〉⊏ &Stream
            exit (this.);
        func _Serialize(Type_, dimension)〈array: &Array(Type_, dimension)〉⊏ &Stream
            exit (this.);

        func _Deserialize(Type_)〈struct: &Type_#cells〉⊏ &Stream
            ____Assure_Fore〈size: int8〉
                test((__fore + size <= __back) = nega)
                    cast Mistake{!'out of bounds'};

            auto bytes ⊏ (dyna Type_)\_Bytes · cells;
            ____Assure_Fore〈size〉;
            loop(auto iter ⊏ ($byte)$struct; auto ordi ⊏ 0; ordi < bytes)
                (iter + ordi). ⊏ (__buffer + __fore).;
                ordi +⊏ 1;
                __fore +⊏ 1;
            exit (this.);

        func _Deserialize(Type_)〈struct: $Type_, cells: uin8〉⊏ &Stream
            exit (this.);
        func _Deserialize(Type_, dimension)〈array: &Array(Type_, dimension)〉⊏ &Stream
            exit (this.);

    type Datum
        prop __pack ⊏ pack Pack{}
            auto _int8  ⊏ int8{1};
            auto _num8  ⊏ num8{2.3};
            auto _com8  ⊏ com8{4.0, 5.0}；
            auto _chunk ⊏ char#5{
                'A', 'B', 'C'
            };
        prop __root     ⊏ ($char)null;
        prop __capacity ⊏ 0;
        prop __size     ⊏ 0;
        prop __instance ⊏ !'abcde';
        prop __pointer  ⊏ make !'abcde';

        ctor &Datum{init: &Init(char)}
            __root     ⊏ make char#(init\_Size);
            __capacity ⊏ init\_Size;
            loop(auto ordi ⊏ 0; ordi < init\_Size)
                (__root + ordi). ⊏ init[ordi];
            __size ⊏ init\_Size;
        ctor ~Datum{}
            free __root;
            __capacity ⊏ 0;
            __size     ⊏ 0;
            free __pointer;

        !! Do语言的序列化操作符方法的示例
        oper <<<〈stream: &Stream〉⊏ &Stream
            !! 序列化定长根本类型
            stream\_Serialize(take)〈__pack〉;

            !! 序列化变长自定义类型
            stream\_Serialize(take)〈__size〉;
            stream\_Serialize(take)〈__root, __size〉;

            !! 序列化变长基本类型
            stream\_Serialize(take, take)〈__instance〉;

            !! 序列化指针类型
            stream\_Serialize(take)〈__pointer〉;    !! 此处将指针当作地址型序列化
            test(__pointer ¬= null)
                stream\_Serialize(take, take)〈__pointer.〉;
            exit stream;

        !! Do语言的反序列化操作符方法的示例
        oper >>>〈stream: &Stream〉⊏ &Stream
            !! 反序列化定长根本类型
            stream\_Deserialize(take)〈__pack〉;

            !! 反序列化变长自定义类型
            free __root;
            stream\_Deserialize(take)〈__size〉;
            __root ⊏ make char#__size{};
            __capacity ⊏ __size;
            stream\_Deserialize(take)〈__root, __size〉;

            !! 反序列化变长基本类型
            stream\_Deserialize(take)〈__instance〉;

            !! 反序列化指针类型
            free __pointer;
            stream\_Deserialize(take)〈__pointer〉;  !! 此处将地址型反序列化为指针
            test(__pointer ¬= null)
                __pointer ⊏ make Char{};
            stream\_Deserialize(take, take)〈__pointer.〉;
            exit stream;

    main Main{}
        auto buffer ⊏ _Serialize〈〉;
        _Deserialize〈buffer〉;

    func _Serialize〈〉⊏> Byte
        auto stream ⊏ Stream{};
        auto datum  ⊏ Datum{};
        stream <<< datum;
        exit stream._Buffer;

    func _Deserialize〈buffer: &Byte〉
        auto stream ⊏ Stream{buffer};
        auto datum  ⊏ Datum{};
        stream >>> datum;

### Do语言的正则表达式

| 类别 | 解析方式 |                         语法示例                         | 操作符 |  功能作用  |          备注          |
| :--: | :------: | :------------------------------------------------------: | :----: | :--------: | :--------------------: |
| 转义 |   循环   |                      `{0:9\{\}\\}`                       |   \    |   转义符   |      转义符自转义      |
|      |          |                                                          |        |            |                        |
| 单项 |   循环   |                          ·[1:]                           |   ·    |   任意符   |      也匹配空白符      |
| 单项 |   循环   |                       {0:9A:Za:z}                        |  {:}   |   枚举集   |      :不单独出现       |
| 单项 |   循环   |                  ((bss9395)@(yeah.net))                  |   ()   |   捕获组   |    组序号为内存顺序    |
| 单项 |   循环   |       ((〈username〉bss9395)@(〈domain〉yeah.net))       |  〈〉  |   组别名   |    组别名只用在组头    |
|      |          |                                                          |        |            |                        |
| 前缀 |   递归   |                   ~{0123456789a:zA:Z}                    |   ~    |   集合非   |      ~只用于集合       |
|      |          |                                                          |        |            |                        |
| 模式 |   循环   |                       !{0:9a:zA:Z}                       |   !    | 停用大小写 | !只用在组头，嵌套有效  |
| 模式 |   循环   |                      !!{0:9a:zA:Z}                       |   !!   | 启用大小写 | !!只用在组头，嵌套有效 |
|      |          |                                                          |        |            |                        |
| 后缀 |   循环   |                      ·[1:]@yeah.net                      |  [:]   |   重复数   |      :不单独出现       |
| 后缀 |   循环   |                     ·[1:]?@yeah.net                      |   ?    |   贪婪与   |      ?不单独出现       |
|      |          |                                                          |        |            |                        |
| 条件 |   循环   |             `yeah.net|gmail.com|outlook.com`             |  `|`   |   匹配或   |      跟状态机有关      |
|      |          |                                                          |        |            |                        |
| 辅助 |   循环   | ((〈username:用户名〉bss9395)@(〈domain:域名〉yeah.net)) | 〈:〉  |   格注释   |   注释排除字符〈:〉    |


相关的类型：Regular
相关关键词：正则表达式、完全匹配、部分匹配

type Regular
    type Enum
        take uin4 = Pattern;                                 !! Pattern的类型全路径是Regular.Enum.Pattern
        prop _case_sensitive   ⊏> Pattern{b#10 >> 0};        !! 此选项相当于在正则表达式的开头添加操作符!!
        prop _case_insensitive ⊏> Pattern{b#10 >> 1};        !! 此选项相当于在正则表达式的开头添加操作符!
        prop _pattern_hold     ⊏> Pattern{_case_sensitive};

        take uin4 = Operate;
        prop _ignore_ione    ⊏> Operate{b#10 >> 0};
        prop _ignore_space   ⊏> Operate{b#10 >> 1};
        prop _ignore_row     ⊏> Operate{b#10 >> 2};
        prop _ignore_line    ⊏> Operate{b#10 >> 3};
        prop _ignore_page    ⊏> Operate{b#10 >> 4};
        prop _ignore_blank   ⊏> Operate{_ignore_space ∨∨ _ignore_row ∨∨ _ignore_line ∨∨ _ignore_page};
        prop _anchor_none    ⊏> Operate{b#10 >> 5};
        prop _anchor_fore    ⊏> Operate{b#10 >> 6};
        prop _anchor_back    ⊏> Operate{b#10 >> 7};
        prop _anchor_full    ⊏> Operate{_anchor_fore ∨∨ _anchor_back};
        prop _retrieve_none  ⊏> Operate{b#10 >> 8};
        prop _retrieve_space ⊏> Operate{b#10 >> 9};
        prop _retrieve_row   ⊏> Operate{b#10 >> 10};
        prop _retrieve_line  ⊏> Operate{b#10 >> 11};
        prop _retrieve_page  ⊏> Operate{b#10 >> 12};
        prop _retrieve_blank ⊏> Operate{_retrieve_space ∨∨ _retrieve_row ∨∨ _retrieve_line ∨∨ _retrieve_page};
        prop _ucs_auto       ⊏> Operate{b#10 >> 13};
        prop _ucs_compact    ⊏> Operate{b#10 >> 14};
        prop _ucs_coded      ⊏> Operate{b#10 >> 15};
        prop _operate_hold   ⊏> Operate{_ignore_none ∨∨ _anchor_none ∨∨ _retrieve_none ∨∨ _ucs_auto};

    type Match
        type Enum
            take Byte = Matched;
            prop _matched_none       ⊏> Matched{`matched_none`};
            prop _matched_completely ⊏> Matched{`matched_completely`};
            prop _matched_partially  ⊏> Matched{`matched_partially`};

!! Do语言的正则表达式的示例
type Main
    func _Match_Insensitive〈〉
        auto keepin  ⊏ !'联系↩Keepin: BSS9395@yeah.net';
        auto regular ⊏ Regular{!'({a:z}[1]{0:z}[0:])@(gmail.com|outlook.com|yeah.net)↩[0:]', Regular.enum._case_insensitive};
        auto fore    ⊏ 0;
        auto length  ⊏ keepin\_size;
        auto match   ⊏ regular\_Match_Completely〈keepin, fore, length, Regular.enum._anchor_full〉;
        Console._Print〈match._matched〉;       !! 输出Regular.Match.enum._match_completely
        Console._Print〈match._captured〈0〉〉;  !! !'BSS9395@yeah.net'

    func _Match_Ignore〈〉
        auto keepin  ⊏ !'联系↩Keepin: BSS9395@yeah.net';
        auto regular ⊏ Regular{!'({a:z}[1]{0:z}[0:])@(gmail.com|outlook.com|yeah.net)↩[0:]', Regular.enum._case_sensitive};
        auto fore    ⊏ 0;
        auto length  ⊏ keepin\_size;
        auto match   ⊏ regular\_Match_Completely〈keepin, fore, length, Regular.enum._ignore_space〉;
        Console._Print〈match._matched〉;       !! 输出Regular.Match.enum._match_completely
        Console._Print〈match._captured〈0〉〉;  !! !'Keepin: BSS9395@yeah.net'

    func _Match_Full〈〉
        auto keepin  ⊏ !'联系↩Keepin: bss9395@yeah.net';
        auto regular ⊏ Regular{!'{a:z}[1]{0:z}[0:]@(gmail.com|outlook.com|yeah.net)↩[0:]', Regular.enum._case_sensitive};
        auto fore    ⊏ 0;
        auto length  ⊏ keepin\_size;
        auto match   ⊏ regular\_Match_Completely〈keepin, fore, length, Regular.enum._anchor_full〉;
        Console._Print〈match._matched〉;       !! 输出Regular.Match.enum._match_none
        Console._Print〈match._captured〈0〉〉;  !! !''

    func _Match_Part〈〉
        auto keepin  ⊏ !'联系↩Keepin: bss9395@yeah.net';
        auto regular ⊏ Regular{!'{a:z}[1]{0:z}[0:]@(gmail.com|outlook.com|yeah.net)↩[0:]', Regular.enum._case_sensitive};;
        auto fore    ⊏ 0;
        auto length  ⊏ keepin\_size;
        auto match   ⊏ regular\_Match_Completely〈keepin, fore, length, Regular.enum._anchor_none〉;
        Console._Print〈match._matched〉;       !! 输出Regular.Match.enum._match_completely
        Console._Print〈match._captured〈0〉〉;  !! !'bss9395@yeah.net'

    func _Match_Line〈〉
        auto keepin  ⊏ !'联系↩Keepin: bss9395@yeah.net';
        auto regular ⊏ Regular{!'{a:z}[1]{0:z}[0:]@(gmail.com|outlook.com|yeah.net)↩[0:]', Regular.enum._case_sensitive};;
        auto fore    ⊏ 0;
        auto length  ⊏ keepin\_size;
        auto match   ⊏ regular\_Match_Completely〈keepin, fore, length, Regular.enum._retrive_line〉;
        Console._Print〈match._matched〉;       !! 输出Regular.Match.enum._match_completely
        Console._Print〈match._captured〈0〉〉;  !! !'bss9395@yeah.net'

    func _Match_Lazy〈〉
        auto keepin  ⊏ !'联系↩Keepin: bss9395@yeah.net,bss9395@gmail.com';
        auto regular ⊏ Regular{!'{0:z@.,}[1:]@(gmail.com|outlook.com|yeah.net)↩[0:]', Regular.enum._case_sensitive};
        auto fore    ⊏ 0;
        auto length  ⊏ keepin\_size;
        auto match   ⊏ regular\_Match_Completely〈keepin, fore, length, Regular.enum._operate_hold〉;
        Console._Print〈match._matched〉;       !! 输出Regular.Match.enum._match_completely
        Console._Print〈match._captured〈0〉〉;  !! !'bss9395@yeah.net'

    func _Match_Greedy〈〉
        auto keepin  ⊏ !'联系↩Keepin: bss9395@yeah.net,bss9395@gmail.com';
        auto regular ⊏ Regular{!'{0:z@.,}[1:]?@(gmail.com|outlook.com|yeah.net)↩[0:]', Regular.enum._case_sensitive};
        auto fore    ⊏ 0;
        auto length  ⊏ keepin\_size;
        auto match   ⊏ regular\_Match_Completely〈keepin, fore, length, Regular.enum._operate_hold〉;
        Console._Print〈match._matched〉;       !! 输出Regular.Match.enum._match_completely
        Console._Print〈match._captured〈0〉〉;  !! !'bss9395@yeah.net'

    !! 部分匹配主要在两种情况下有用：实时验证用户输入和增量，以及多分段匹配。
    !! 0. 如果将相同的正则表达式与主题字符串进行匹配会导致完全匹配，则会像往常一样进行报告：
    !! 1. 如果在匹配时发现多个部分匹配（但没有完全匹配），那么QRegularExpressionMatch将报告找到的第一个部分匹配。
    func _Match_Partially〈〉
        auto keepin  ⊏ !'bss9395@yeah.net';
        auto regular ⊏ Regular{!'{0:z}[1:]©(gmail.com|outlook.com|yeah.net)↩[0:]', Regular.enum._case_sensitive};
        auto fore    ⊏ 0;
        auto length  ⊏ keepin\_size;
        auto match   ⊏ regular\_Match_Partially〈keepin, fore, length, Regular.enum._operate_hold〉;
        Console._Print〈match._matched〉;       !! 输出Regular.Match.enum._match_partially
        Console._Print〈match._captured〈0〉〉;  !! !'bss9395'

    func _Match_Byte〈〉
        auto keepin  ⊏ Byte{!'联系↩Keepin: bss9395@yeah.net', Byte.enum._coded_into_compact};
        auto regular ⊏ Regular{!'{0:z}[1:]@(gmail.com|outlook.com|yeah.net)↩[0:]', Regular.enum._case_sensitive};
        auto fore    ⊏ 0;
        auto length  ⊏ keepin\_size;
        auto match   ⊏ regular\_Match_Completely〈keepin, fore, length, Regular.enum._ucs_compact〉;
        Console._Print〈match._matched〉;       !! 输出Regular.Match.enum._match_completely
        Console._Print〈match._captured〈0〉〉;  !! !`bss9395@yeah.net`

### Do语言的运行库与归档库

相关关键字：bind、load、take、fork
相关关键词：运行库、符号表、全量编译、足量编译、动态加载、归档库、终端命令行、工作文件夹、导入路径、根路径、编译器根路径、编译器的项目根路径、进程根路径

Do语言的运行库包含完整的符号表信息，因此不区分静态库与动态库。
Do语言使用bind关键字在编译期静态全量编译运行库中的类型，程序运行时不再依赖运行库。
Do语言使用load关键字在编译期静态足量编译运行库中的类型，程序运行时校验运行库文件再动态加载。当运行库中的类型不再使用时，其引用计数归0将自动卸载。

Do语言的项目组织结构采用模块化的方案，模块文件夹通常按指定格式压缩成归档库，归档库中通常包含源代码、配置、图片、音频、视频、资源等等子项。
Do语言的终端命令行通过Do语言解释器解释执行语句块，默认以启动时的文件夹为工作文件夹。

Do语言规范规定导入路径中的物理文件名省略所有的后缀，物理文件名之前的路径采用分隔符\，物理文件名之后的路径采用分隔符.。Do语言的导入路径的末项标签名必须是文件或者类型，只有末项标签名亦或者其别名才能用在代码中，末项标签名之前的路径标签名不能用在代码中。
Do语言导入路径的类型，其实是导入类型的声明，而不是导入类型的定义。

Do语言编译器的项目根路径，默认继承自编译器根路径。Do语言的导入路径的根路径，在编译期默认继承自编译器的项目根路径，在运行期默认继承自上下文的进程根路径。Do语言的根路径通过self._rootpaths环境变量获取，通常情形下根路径包含当前文件夹以及系统库路径。Do语言规范规定若导入路径有歧义，则以首个导入路径完全匹配项为准。


!! Do语言的运行库的结构
\folder\library     !! 运行库library#library
├ main              !! 源文件main#do
│ ├ type Main       !! 入口类Main
│   ├ type Routine  !! 入口类Main.Routine
├ another           !! 源文件another#do
│ ├ type Type       !! 普通类Type
│ ├ type Class      !! 普通类Class
│   ├ func _Func    !! 成员方法_Func
├ other.another     !! 源文件other\another#do
  ├ type Type       !! 普通类Type
  ├ type Class      !! 普通类Class
    ├ func _Func    !! 成员方法_Func

!! Do语言的运行库的示例
type Main
    main Main{}
        Console._Print〈self._programpath〉;
        Console._Print〈self._programname〉;
        Console._Print〈self._workingfolder〉;
        Console._Print〈self._rootpaths〉;
        self._rootpaths +⊏ !'\folder\';

    func _Compilation_Static〈〉
        Console._Print〈self._programpath〉;
        Console._Print〈self._programname〉;
        Console._Print〈self._workingfolder〉;
        Console._Print〈self._rootpaths〉;
        deem
            bind library.another.Class;            !! 编译期静态全量编译library.another.Class类型
            auto class ⊏ make Class{};
            class._Func〈〉;
            free class;

            bind library.another.Class = Another;  !! 编译期静态全量编译library.another.Class类型，然后别名为Another
            auto another ⊏ make Another{};
            another._Func〈〉;
            free another;
        what(anomaly: &&$Anomaly)
            Console._Print〈!anomaly:〉;

    func _Compilation_Dynamic〈〉
        Console._Print〈self._programpath〉;
        Console._Print〈self._programname〉;
        Console._Print〈self._workingfolder〉;
        Console._Print〈self._rootpaths〉;
        deem
            load library.another.Class;                                   !! 编译期静态足量编译library.another.Class类型，运行期校验库文件再动态加载
            auto class ⊏ make Class{};
            class._Func〈〉;
            free class;                                                   !! 当library.another.Class不再使用时，其引用计数归0将自动卸载

            auto loadpaths ⊏ self._rootpaths;
            loadpaths +⊏ !'\Applications\';
            load{loadpaths ⊏ loadpaths} library.another.Class = Another;  !! 编译期静态足量编译library.another.Class类型，运行期校验库文件再动态加载，然后别名为Another
            auto another ⊏ make Another{};
            another._Func〈〉;
            free another;                                                 !! 当library.another.Class不再使用时，其引用计数归0将自动卸载
        what(anomaly: &&$Anomaly)
            Console._Print〈!anomaly:〉;


!! Do语言的归档库的结构
\workingfolder\            !! 工作文件夹
├ archive#archive          !! 归档库文件archive
  ├ sources\               !! 源代码文件夹sources
  │ ├ main#do              !! 源代码文件main
  │ │ ├ type Main          !! 入口类Main
  │ │   ├ type Routine     !! 入口类Main.Routine
  │ │   ├ func _Help       !! 成员方法_Help
  │ │   ├ func _Calculate  !! 成员方法_Calculate
  │ │   ├ func _Func       !! 成员方法_Func
  │ ├ anothor#do           !! 源代码文件another
  │ │ ├ type Type          !! 普通类Type
  │ │ ├ type Class         !! 普通类Class
  │ ├ other\
  │   ├ another#do
  │     ├ type Type
  │     ├ type Class
  ├ configs\               !! 配置文件夹configs
  │ ├ readme#note
  │ ├ config#note
  ├ images\                !! 图片文件夹images
  │ ├ logo#eagb
  ├ audios\                !! 音频文件夹audios
  │ ├ logo#mp3
  ├ videos\                !! 视频文件夹videos
  │ ├ logo#mp4
  ├ resources\             !! 资源文件夹resources
    ├ logo#design

!! Do语言的归档库的示例
!! 在\workingfolder\文件夹中启动终端命令行，终端命令行通过Do语言解释器解释执行语句块
``` Do语言的终端命令行，相当于type Main.main Main{}
take archive.sources.main.Main = MainDo;
deem
    MainDo._Help〈〉;

    flex result ⊏ MainDo._Calculate〈1234, 5678〉;
    Console._Print〈result〉;

    flex maindo ⊏ &&make MainDo{};
    maindo._Help〈〉;
    result ⊏ maindo._Func〈〉;
    Console._Print〈result〉;
what(anomaly: &&$Anomaly)
    Console._Print〈!anomaly:〉;


func ____Process〈〉
    flex rootpaths ⊏ self._rootpaths;
    rootpaths +⊏ !'\Applications\';
    flex workingfolder ⊏ self._workingfolder;
    flex process ⊏ &&fork{rootpaths ⊏ rootpaths, workingfolder ⊏ workingfolder} MainDo{lside: 1234, rside: 5678, help ⊏ nega};
    pick process._State_Transition()
        Console._Print〈process._State〉;                                             !! 进程状态相关
    pick process._Output_Emergency()
        flex data ⊏ process._Read〈Process.enum._output_emergency〉;                  !! 输出紧急通道
        Console._Print〈data〉;
    pick process._Output_Routine()
        flex data ⊏ process._Read〈Process.enum._output_routine〉;                    !! 输出惯例通道
        Console._Print〈data〉;
    process._Start〈Process.enum._foreground〉;
    Console._Print〈process._Process_Id〉;
    process._Write〈Process.enum._input_emergency, !'An emergency has occurred!'〉;   !! 输入紧急通道
    process._Write〈Process.enum._input_routine, !'Hello, World!'〉;                  !! 输入惯例通道
    flex result ⊏ process._Sync〈〉;                                                  !! 阻塞等待主协程运行结束
    test(process._exit_code = 0 ? process._running_tasks = 0)                         !! 主协程运行结束以后，可能还有其它前台协程或者后台协程在运行
        Console._Print〈result〉;
    !! 析构process，若进程未结束则结束进程，进程结束的标志是没有正在运行的协程
____Process〈〉;
!! 脚本运行结束
```

!! Do语言的导入路径的示例
take dolang.base;                     !! 导入dolang归档库中的base源代码文件
take dolang.base.Console;             !! 导入base源代码文件中的Console类型
take dolang.base = dobase;            !! 将base源代码文件别名为dobase
take dolang.base.Console = Terminal;  !! 将Console类型别名为Terminal
type Main
    type Depend0
        prop _depend1 ⊏ Depend1{};
    type Depend1
        prop _depend0 ⊏ Depend0{};

    main Main{}
        auto  depend0 ⊏ Depend0{};    !! 编译期错误：类型依赖定义

    func _Bind〈〉
        bind library.base.Console;
        bind library.base.Console = Terminal;
        Console._Print〈!'Hello, World!'〉;
        Terminal._Print〈!'Hello, World!'〉;
    func _Load〈〉
        load library.base.Console;
        load library.base.Console = Terminal;
        Console._Print〈!'Hello, World!'〉;
        Terminal._Print〈!'Hello, World!'〉;

### Do语言用于界面应用程序

相关的类型：Widget
相关关键词：界面应用程序

传统的HTML+CSS+JavaScript作浏览器网页开发，完全可以采用Do语言重写。
HTML标签在Do语言中是类体实例，CSS层叠样式表在Do语言中是成员属性，JavaScript脚本在Do语言中是成员方法与操作符方法以及协程。

type Main: HWidget
    type Controller
        post _Width  ⊏> __width;
        post _Factor ⊏> num8
            exit __factor;
        post _Signal ⊏> width: int8, factor: num8
            exit __signal;

        prop __width  ⊏ 1
            test(__width  ¬= para)
                __width ⊏ para;
            emit _Width;
        prop __factor ⊏ 1.0;
            test(__factor ¬= para)
                __factor ⊏ para;
            emit _Factor;                                       !! 使用exit语句，间接发射_Signal
        prop __signal ⊏ width: 1, factor: 1.0
            bool flag ⊏ nega;
            test(__signal\width  ¬= width)
                flag ⊏ posi;
                __signal\width  ⊏ width;
            test(__signal\factor ¬= factor)
                flag ⊏ posi;
                __signal\factor ⊏ factor;
            test(flag = posi)
                emit _Signal{__signal\width, __signal\factor};  !! 绕过exit语句，直接发射_Signal

    prop __label      ⊏ make Label{};
    prop __controller ⊏ make Controller{};

    main Main{}
        this._saturateV   ⊏ HWidget.Enum._saturate_none;
        this._align_major ⊏ HWidget.Enum._align_hcenter ∨∨ HWidget.Enum._align_vcenter;
        this._align_minor ⊏ HWidget.Enum._align_hcenter ∨∨ HWidget.Enum._align_vcenter;
        this._margins     ⊏ [0, 0, 0, 0];
        this._spacingH    ⊏ 0;
        this.__reverse    ⊏ 100;
        this.__anti       ⊏ 100;

        __label._reverse      ⊏ 50;
        __label._anti         ⊏ 50;
        __label._image_source ⊏ !'folder\image#eagb';
        this._Attach〈_label, 0.0〉;
        this._Show〈〉;  !! _Show方法是非阻塞的，此处会进入主协程的事件循环

    func _Func〈〉
        func ____Routine〈width: int8, factor: num8〉
            __label._width ⊏ (int8)(width · factor);
        auto cotack ⊏ asyn ____Routine〈1, 2.0〉;
        cotask._Start〈Task.Enum._background〉;

        pick _controller._Width〈width: int8〉, _controller._Factor〈factor: num8〉
            __label._width ⊏ (int8)(width · factor);  !! pick在第一次连接信号时，会自动读取一次_controller._Width和_controller._Factor
            __label._width ⊏ (int8)(_controller._Width · _controller._Factor);

        pick _controller._Signal〈width: int8, factor: num8〉
            __label._width ⊏ (int8)(width · factor);  !! pick在第一次连接信号时，会自动读取一次_controller._Signal


### Do语言用于数值计算与符号计算

相关的类型：Vector(Numerical_)、Matrix(Numerical_)
相关关键词：向量、矩阵、数值计算、符号计算

Do语言内置向量类型与矩阵类型用于数值计算，向量类型与矩阵类型都是数组类型的泛型模板特例化类型。

type Main
    !! Do语言的向量的示例
    func _Vector〈〉
        auto vector_int8_square ⊏ [0:10:1];     !! 生成Vector(int8){11}实例
        auto vector_int8_angle  ⊏ [0:10:1〉;     !! 生成Vector(int8){10}实例
        auto vector_num8_square ⊏ [0:10:1.0];   !! 生成Vector(num8){11}实例
        auto vector_num8_angle  ⊏ [0:10:1.0〉;   !! 生成Vector(num8){10}实例

        !! Do语言生成向量[0:10:1]的等价过程
        loop(auto ordi ⊏ 0; init <= stop)
            vector_int8_square[ordi] ⊏ init;
            ordi +⊏ 1;
            inti +⊏ step;

    !! Do语言的矩阵的示例
    func _Matrix〈〉
        auto matrix ⊏ num8[3, 2, 1]{#{
            04, 05, 06,
            01, 02, 03,
        }};
        matrix[0, 0, 0] = 01;
        matrix[1, 0, 0] = 02;
        matrix[2, 0, 0] = 03;
        matrix[0, 1, 0] = 04;
        matrix[1, 1, 0] = 05;
        matrix[2, 1, 0] = 06;

        uin8 ordiR = 2;
        uin8 ordiI = 1;
        uin8 ordiA = 0;
          matrix [ordiR, ordiI, ordiA] = 06;
        (⌟matrix)[ordiI, ordiR, ordiA] = 06;

    !! Do语言呈现曲面的示例
    func _Mesh_Surface〈〉
        auto vectorR ⊏ [0:3:1.0];
        auto vectorI ⊏ [0:2:1.0];
        auto surface ⊏ Array(num8, 2){vectorR._Size, vectorI._Size};
        loop(auto ordiR ⊏ 0; ordiR < vectorR._Size)
            loop(auto ordiI ⊏ 0; ordiI < vectorI._Size)
               surface[ordiR, ordiI] ⊏ vectorR[ordiR] ·· 2 + vectorI[ordiI] ·· 2;
               ordiI +⊏ 1;
            ordiR +⊏ 1;
        Console._Mesh〈vectorR, vectorI, surface〉;

        !! Do语言的序数标语法
        !! loop(auto [ordiR, ordiI] : vectorR, vectorI)    !! 序数标语法须要实例具有下标操作符函数
        !!     surface[ordiR, ordiI] ⊏ vectorR[ordiR] ·· 2 + vectorI[ordiI] ·· 2;


### 案例：Do语言的数据结构

相关关键词：线性链表、一级指针、二级指针

Do语言原生支持多级指针类型以及多级指针的别名类型，这使得Do语言非常适合用于实现高级数据结构。

!! 线性链表数据结构
_root              node1              node2              node3
|_datum, _next| => |_datum, _next| => |_datum, _next| => |_datum, _next| -> null

// C++语言的二级指针的示例
#include <iostream>
#include <string>
struct List {
    struct Node {
        std::string _datum = "";
        Node* _next = nullptr;
        Node(const std::string& datum) {
            _datum = datum;
        }
    };

    Node _root = Node("_root");
    void _Create() {
        Node* node1 = new Node("node1");
        Node* node3 = new Node("node3");
        _root._next = node1;
        node1->_next = node3;
    }
    void _Insert() {
        Node* node2 = new Node("node2");
        Node** iter = &_root._next;
        iter = &((*iter)->_next);
        node2->_next = (*iter);
        (*iter) = node2;
    }
    void _Print() {
        std::string repr = "";
        repr += "[";
        for (Node* iter = &_root; iter != nullptr;) {
            if (iter != &_root) {
                repr += ", ";
            }
            repr += iter->_datum;
            iter = iter->_next;
        }
        repr += "]";
        std::cout << repr << std::endl;
    }
};
int main(int argc, char* argv[]) {
    List list = List();
    list._Create();
    list._Insert();
    list._Print();
    return 0;
}

!! Do语言的二级指针的示例
type Main
    type List
        type Node
            prop _datum ⊏ !'';
            prop _next  ⊏ ($Node)null;
            ctor &Node{datum: &Char}
                _datum ⊏ datum;

        prop _root ⊏ Node{!'_root'};
        func _Create〈〉
            auto node1 ⊏ make Node{!'node1'};
            auto node3 ⊏ make Node{!'node3'};
            _root\_next ⊏ node1;
            node1._next ⊏ node3;
        func _Insert〈〉
            auto node2 ⊏ make Node{!'node2'};
            auto iter  ⊏ $(_root\_next);  !! iter是二级指针，类型是$$Node
            iter ⊏ $(iter.._next);        !! 赋值号右侧iter. = _root\_next，iter.._next = _root\_next._next = node1._next = node3
            node2._next ⊏ iter.;          !! node2._next = node3
            iter. ⊏ node2;                !! node1._next = node2
        func _Print〈〉
            auto repr ⊏ !'';
            repr +⊏ !'[';
            loop(auto iter ⊏ $_root; iter ¬= null)
                test(iter ¬= $_root)
                    repr +⊏ !', ';
                repr +⊏ iter._datum;
                iter ⊏ iter._next;
            repr +⊏ !']';
            Console._Print〈repr〉;

    main Main{}
        auto list ⊏ List{};
        list\_Create〈〉;
        list\_Insert〈〉;
        list\_Print〈〉;


### 案例：Do语言的智能指针

相关关键词：智能指针、内存泄露、数据结构

C++语言的智能指针循环引用可能会导致内存泄露。
Do语言原生支持引用类型，相当于C++语言的智能指针，引用类型循环引用可能会导致内存泄露。

// C++语言的智能指针循环引用的示例
#include <iostream>
#include <memory>
int main(int argc, char* argv[]) {
    struct Item0;
    struct Item1;
    struct Item2;
    struct Item0 {
        std::shared_ptr<Item1> _ptr = nullptr;
        explicit Item0() {
            std::cout << __FUNCTION__ << std::endl;
        }
        virtual ~Item0() {
            std::cout << __FUNCTION__ << std::endl;
        }
    };
    struct Item1 {
        std::shared_ptr<Item2> _ptr = nullptr;
        explicit Item1() {
            std::cout << __FUNCTION__ << std::endl;
        }
        virtual ~Item1() {
            std::cout << __FUNCTION__ << std::endl;
        }
    };
    struct Item2 {
        std::shared_ptr<Item0> _ptr = nullptr;
        explicit Item2() {
            std::cout << __FUNCTION__ << std::endl;
        }
        virtual ~Item2() {
            std::cout << __FUNCTION__ << std::endl;
        }
    };

    std::shared_ptr<Item0> pItem0(new Item0());  // pItem0的引用计数为1
    std::shared_ptr<Item1> pItem1(new Item1());  // pItem1的引用计数为1
    std::shared_ptr<Item2> pItem2(new Item2());  // pItem2的引用计数为1
    pItem0->_ptr = pItem1;                       // pItem1的引用计数为2
    pItem1->_ptr = pItem2;                       // pItem2的引用计数为2
    pItem2->_ptr = pItem0;                       // pItem0的引用计数为2
    // pItem2超出限定域，pItem2的引用计数减少到1
    // pItem1超出限定域，pItem1的引用计数减少到1
    // pItem0超出限定域，pItem0的引用计数减少到1
    // pItem0与pItem1与pItem2都不会释放内存
    return 0;
}

// C++语言的智能数据结构的示例
#include <iostream>
#include <memory>
int main(int argc, char* argv[]) {
    struct Type {
        double __value = 0.0;
        explicit Type(double value) {
            __value = value;
        }
        virtual ~Type() {
            std::cout << "[" << __FUNCTION__ << "]" << std::endl;
        }

        operator double& () {
            std::cout << "[" << __FUNCTION__ << "]" << std::endl;
            return __value;
        }

        static void _Overload(std::shared_ptr<Type> value) {
            std::cout << "[" << __FUNCTION__ << "] " << (*value) << ", " << (*value) << std::endl;
        }

        static void _Overload(Type *value) {
            std::cout << "[" << __FUNCTION__ << "] " << (*value) << ", " << (*value) << std::endl;
        }
    };

    auto array = std::shared_ptr<std::shared_ptr<Type>[10]>(new std::shared_ptr<Type>[10]);
    auto item = std::shared_ptr<Type>(new Type(12.34));  // item的引用计数为1
    array[0] = item;                                     // item的引用计数为2
    auto retrive = array[0];                             // item的引用计数为3
    Type::_Overload(retrive);
    Type::_Overload(retrive.get());

    retrive.reset();                                     // retrive的底层引用计数减1，重置其引用计数为0，重置其引用指针为nullptr
    std::cout << retrive.use_count() << std::endl;       // retrive的引用计数为0
    std::cout << retrive.get() << std::endl;             // retrive的引用指针为nullptr
    std::cout << item.use_count() << std::endl;          // item的引用计数为2
    std::cout << item.get() << std::endl;                // item的引用指针不为nullptr
    // 自动析构retrive
    // 自动析构item
    // 自动析构array数组及其元素
    // 自动销毁item的引用指针的实例
    return 0;
}


!! Do语言的智能数据结构的示例
type Main
    type Type
        prop __value ⊏ 0.0;
        ctor &Type{value: num8}
            Console._Print〈comp._class_function_name〉;
            __value ⊏ value;
        ctor ~Type{}
            Console._Print〈comp._class_function_name〉;

        oper !〈format: !''〉⊏> Char
            exit !'{__value}';

        func _Function〈item: &&$Type〉
            Console._Print〈comp._class_function_name〉;
            Console._Print〈!item.〉;

    main Main{}
        auto array ⊏ &&make &&$Type[10]{};  !! array的类型是&&$(&&$Type[10])
        auto item  ⊏ &&make Type{12.34};    !! item的引用计数为1
        array[0] ⊏ item;                    !! item的引用计数为2
        auto retrive ⊏ array[0];            !! item的引用计数为3
        Type._Function〈retrive〉;

        auto reset ⊏ retrive._Reset〈〉;     !! 重置retrive的引用地址为null，引用计数保持不变
        Console._Print〈retrive._Refer〉;    !! retrive的引用计数为3
        Console._Print〈retrive._Address〉;  !! retrive的引用地址为null
        Console._Print〈item._Refer〉        !! item的引用计数为3
        Console._Print〈item._Address〉;     !! item的引用地址为null
        free reset;                         !! 手动销毁item的引用指针的实例
        !! 自动析构retrive
        !! 自动析构item
        !! 自动析构array数组及其元素

